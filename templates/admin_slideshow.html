<!DOCTYPE html>
<html>
<head>
    <title>管理者用ウェディングスライドショー</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow-x: hidden;
        }

        .slider-row {
            width: 100%;
            overflow: hidden;
            position: relative;
            white-space: nowrap;
        }

        .top-row {
            height: 20vh;
            background: rgba(0, 0, 0, 0.8);
        }

        .middle-row {
            height: 60vh;
            background: rgba(0, 0, 0, 0.9);
        }

        .bottom-row {
            height: 20vh;
            background: rgba(0, 0, 0, 0.8);
        }

        .slide-track {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
        }
        
        .slide-track.animate {
            animation: scroll 40s linear infinite;
        }

        .slide-track img {
            display: inline-block;
            margin: 10px;
        }

        .top-row img, .bottom-row img {
            height: calc(20vh - 20px);
            width: auto;
        }

        .middle-row img {
            height: calc(60vh - 20px);
            width: auto;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* アニメーションを無効化するクラス（初期状態） */
        .slide-track.init {
            animation: none;
        }
    </style>
</head>
<body>
    <!-- 上段のスライダー -->
    <div class="slider-row top-row">
        <div class="slide-track" id="topTrack" data-first-set-length="{{ photos_top|length }}">
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>

    <!-- 中段のスライダー -->
    <div class="slider-row middle-row">
        <div class="slide-track" id="middleTrack" data-first-set-length="{{ photos_middle|length }}">
            {% for photo in photos_middle %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_middle %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>

    <!-- 下段のスライダー -->
    <div class="slider-row bottom-row">
        <div class="slide-track" id="bottomTrack" data-first-set-length="{{ photos_bottom|length }}" data-offset="{{ bottom_offset }}">
            {% for photo in photos_bottom %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_bottom %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>

    <!-- 現在の写真リストをJSON形式で埋め込み（リアルタイム更新用） -->
    <script type="application/json" id="slideshow-data">
        {{ {
            'photos': photos,
            'photoUrls': photo_urls,
            'bottomOffset': bottom_offset
        } | tojson }}
    </script>

    <script>
        // 固定のアニメーション速度（秒/ループ）- この値を変えることで速度を調整可能
        const FIXED_ANIMATION_DURATION = 60; // 60秒で1ループ（1セット分を移動）

        // 埋め込んだ写真リストを取得して現在の状態を保持
        const configElement = document.getElementById('slideshow-data');
        const uploadsBaseUrl = "{{ url_for('serve_upload', filename='__PLACEHOLDER__') }}".replace('__PLACEHOLDER__', '');
        let currentPhotos = [];
        let currentPhotoUrls = [];
        let bottomOffset = 1;
        try {
            const parsed = JSON.parse(configElement.textContent);
            currentPhotos = Array.isArray(parsed.photos) ? parsed.photos.slice() : [];
            currentPhotoUrls = Array.isArray(parsed.photoUrls) ? parsed.photoUrls.slice() : [];
            bottomOffset = Number(parsed.bottomOffset) || 1;
        } catch (e) {
            console.warn('Failed to parse slideshow config:', e);
            currentPhotos = [];
            currentPhotoUrls = [];
            bottomOffset = 1;
        }

        let lastPhotoCount = currentPhotos.length;
        let refreshTimer = null;
        let fetchInProgress = false;
        let lastStorageTimestamp = Date.now();
        const topTrack = document.getElementById('topTrack');
        const middleTrack = document.getElementById('middleTrack');
        const bottomTrack = document.getElementById('bottomTrack');

        function scheduleRefresh() {
            if (refreshTimer) {
                return;
            }
            refreshTimer = setTimeout(() => {
                refreshTimer = null;
                fetchLatestPhotos();
            }, 600);
        }

        // BroadcastChannelで他タブからの通知を受け取る
        try {
            const channel = new BroadcastChannel('photo_upload');
            channel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'photo_uploaded') {
                    scheduleRefresh();
                }
            });
        } catch (e) {
            console.log('BroadcastChannel not supported in this browser.');
        }

        // LocalStorageを使ったフォールバック（同一ブラウザ内）
        setInterval(() => {
            try {
                const stored = localStorage.getItem('last_uploaded_photo');
                if (!stored) {
                    return;
                }
                const data = JSON.parse(stored);
                if (!data || !data.filename || !data.timestamp) {
                    return;
                }
                if (data.timestamp > lastStorageTimestamp && !currentPhotos.includes(data.filename)) {
                    lastStorageTimestamp = data.timestamp;
                    scheduleRefresh();
                }
            } catch (error) {
                // LocalStorageが使えない場合は無視
            }
        }, 2000);

        // サーバーに問い合わせて新しい写真がないか確認（フォールバック）
        setInterval(() => {
            fetchLatestPhotos();
        }, 4000);

        function fetchLatestPhotos() {
            if (fetchInProgress) {
                return;
            }
            fetchInProgress = true;
            fetch('/api/photos')
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Network error');
                    }
                    return response.json();
                })
                .then((data) => {
                    if (!data || !Array.isArray(data.photos)) {
                        return;
                    }
                    handlePhotoListUpdate(data.photos, data.photo_urls);
                })
                .catch(() => {
                    // ネットワークエラー時は何もしない（次回に再試行）
                })
                .finally(() => {
                    fetchInProgress = false;
                });
        }

        function buildPhotoUrl(filename) {
            if (!filename) {
                return '';
            }
            return `${uploadsBaseUrl}${encodeURIComponent(filename)}`;
        }

        function handlePhotoListUpdate(newPhotos, newPhotoUrls) {
            if (!Array.isArray(newPhotos)) {
                return;
            }
            if (newPhotos.length < currentPhotos.length) {
                window.location.reload();
                return;
            }
            if (newPhotos.length === currentPhotos.length) {
                return;
            }

            const startIndex = currentPhotos.length;
            const additions = newPhotos.slice(startIndex);
            const additionUrls = Array.isArray(newPhotoUrls)
                ? newPhotoUrls.slice(startIndex)
                : additions.map(buildPhotoUrl);

            additions.forEach((photo, index) => {
                const url = additionUrls[index] || buildPhotoUrl(photo);
                appendNewPhoto(photo, url);
            });

            currentPhotos = newPhotos.slice();
            if (Array.isArray(newPhotoUrls)) {
                currentPhotoUrls = newPhotoUrls.slice();
            } else {
                additionUrls.forEach((url) => currentPhotoUrls.push(url));
            }
            lastPhotoCount = currentPhotos.length;
        }

        function createImageElement(url, filename) {
            const img = document.createElement('img');
            img.src = url || buildPhotoUrl(filename);
            img.alt = 'Photo';
            return img;
        }

        function insertPhotoIntoTrack(track, url, insertIndex) {
            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            const index = insertIndex === undefined
                ? firstSetLength
                : Math.max(0, Math.min(insertIndex, firstSetLength));
            const childrenSnapshot = Array.from(track.children);
            const primaryRef = childrenSnapshot[index] || null;
            const duplicateRef = childrenSnapshot[firstSetLength + index] || null;

            const img = createImageElement(url);
            const duplicate = createImageElement(url);

            track.insertBefore(img, primaryRef);
            if (duplicateRef) {
                track.insertBefore(duplicate, duplicateRef);
            } else {
                track.appendChild(duplicate);
            }

            track.dataset.firstSetLength = firstSetLength + 1;
        }

        function appendNewPhoto(photo, url) {
            const topInsertIndex = Number(topTrack.dataset.firstSetLength || 0);
            insertPhotoIntoTrack(topTrack, url, topInsertIndex);

            const middleInsertIndex = Number(middleTrack.dataset.firstSetLength || 0);
            insertPhotoIntoTrack(middleTrack, url, middleInsertIndex);

            const bottomFirstLength = Number(bottomTrack.dataset.firstSetLength || 0);
            const offset = Number(bottomTrack.dataset.offset || bottomOffset || 1);
            const bottomInsertIndex = Math.max(0, bottomFirstLength - offset);
            insertPhotoIntoTrack(bottomTrack, url, bottomInsertIndex);
        }
 
        // 各トラックの画像を適切に複製し、アニメーションを設定
        function initializeSlideshow() {
            const tracks = document.querySelectorAll('.slide-track');
            
            tracks.forEach((track) => {
                // 初期状態を設定（アニメーションを無効化）
                track.classList.add('init');
                
                const images = track.querySelectorAll('img');
                
                if (images.length === 0) {
                    // 画像がない場合はアニメーションを開始しない
                    return;
                }
                
                // すべての画像が読み込まれるまで待つ
                let loadedCount = 0;
                const totalImages = images.length;
                
                function checkAllLoaded() {
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        // すべての画像が読み込まれたらアニメーションを開始
                        startAnimation(track);
                    }
                }
                
                // 既に読み込まれている画像をカウント
                images.forEach(img => {
                    if (img.complete) {
                        checkAllLoaded();
                    } else {
                        img.addEventListener('load', checkAllLoaded);
                        img.addEventListener('error', checkAllLoaded); // エラー時も続行
                    }
                });
                
                // タイムアウト（5秒後には強制的に開始）
                setTimeout(() => {
                    if (track.classList.contains('init')) {
                        startAnimation(track);
                    }
                }, 5000);
            });
        }
        
        // アニメーションを開始
        function startAnimation(track) {
            // 初期状態のクラスを削除
            track.classList.remove('init');
            
            // 固定のアニメーション時間を設定
            track.style.animation = `scroll ${FIXED_ANIMATION_DURATION}s linear infinite`;
            
            // アニメーションクラスを追加
            track.classList.add('animate');
        }
        
        // ページ読み込み時に実行
        window.addEventListener('load', function() {
            // DOMが完全に読み込まれてから少し遅延して実行
            setTimeout(initializeSlideshow, 100);
        });
        
        // ページが表示されているときに実行（戻ってきた時など）
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                // ページが表示されたら、アニメーションが動作しているか確認
                const tracks = document.querySelectorAll('.slide-track');
                tracks.forEach(track => {
                    if (!track.classList.contains('animate') && track.querySelectorAll('img').length > 0) {
                        startAnimation(track);
                    }
                });
            }
        });
    </script>
</body>
</html>