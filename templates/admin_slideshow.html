<!DOCTYPE html>
<html>
<head>
    <title>管理者用ウェディングスライドショー</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow-x: hidden;
        }

        .slider-row {
            width: 100%;
            overflow: hidden;
            position: relative;
            white-space: nowrap;
        }

        .top-row {
            height: 42vh;
            background: rgba(0, 0, 0, 0.85);
            margin-bottom: 8px;
        }

        .middle-row {
            height: 58vh;
            background: rgba(0, 0, 0, 0.92);
        }

        body.single-lane .top-row {
            display: none;
        }

        body.single-lane .middle-row {
            height: 90vh;
            margin-top: 5vh;
            background: rgba(0, 0, 0, 0.9);
        }

        body.single-lane .middle-row img {
            height: calc(90vh - 20px);
        }

        .slide-track {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
        }
        
        .slide-track.animate {
            /* アニメーションはJavaScriptで制御 */
        }

        .slide-track img {
            display: inline-block;
            margin: 8px;
            border-radius: 18px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        .top-row img {
            height: calc(38vh - 16px);
            width: auto;
        }

        .middle-row img {
            height: calc(54vh - 16px);
            width: auto;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* アニメーションを無効化するクラス（初期状態） */
        .slide-track.init {
            animation: none;
        }
    </style>
</head>
<body class="theme-dark{% if not photos_top %} single-lane{% endif %}">
    {% if photos_top %}
    <div class="slider-row top-row">
        <div class="slide-track" id="topTrack" data-first-set-length="{{ photos_top|length }}">
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>
    {% endif %}

    <!-- 下段のスライダー -->
    <div class="slider-row middle-row">
        <div class="slide-track" id="middleTrack" data-first-set-length="{{ photos_recent|length }}">
            {% for photo in photos_recent %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_recent %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>

    <script type="application/json" id="slideshow-data">
        {{ {
            'photos': photos,
            'photoUrls': photo_urls,
            'topPhotos': photos_top,
            'topPhotoUrls': top_photo_urls,
            'recentPhotos': photos_recent,
            'recentPhotoUrls': recent_photo_urls
        } | tojson }}
    </script>

    <script>
        // アニメーション速度（ピクセル/秒）- 画像数や幅に関係なく一定の速度を保証
        // 1レーン目（上）: 速い（50px/秒）
        // 2レーン目（下）: 遅い（30px/秒）
        const TOP_ANIMATION_SPEED = 50;  // 1レーン目（上）の速度（px/秒）
        const MIDDLE_ANIMATION_SPEED = 30;  // 2レーン目（下）の速度（px/秒）
        
        // レーンに応じたアニメーション速度を取得
        function getAnimationSpeed(track) {
            if (track && track.id === 'topTrack') {
                return TOP_ANIMATION_SPEED;
            } else {
                return MIDDLE_ANIMATION_SPEED;
            }
        }
        
        // レーンに応じたアニメーション時間を取得（firstSetWidthに基づいて計算）
        function getAnimationDuration(track, firstSetWidth) {
            if (!track || firstSetWidth <= 0) {
                // フォールバック値
                return track && track.id === 'topTrack' ? 100 : 150;
            }
            const speed = getAnimationSpeed(track);
            // アニメーション時間 = 距離 / 速度
            // firstSetWidth（1セット分の距離）を移動するのにかかる時間
            return firstSetWidth / speed;
        }
        const configElement = document.getElementById('slideshow-data');
        const uploadsBaseUrl = "{{ url_for('serve_upload', filename='__PLACEHOLDER__') }}".replace('__PLACEHOLDER__', '');
        const MIN_POLL_INTERVAL = 4000;
        const MAX_POLL_INTERVAL = 30000;
        const POLL_GROWTH_FACTOR = 1.6;
        let currentPhotos = [];
        let currentPhotoUrls = [];
        let topPhotos = [];
        let topPhotoUrls = [];
        let recentPhotos = [];
        let recentPhotoUrls = [];
        
        // アニメーション制御用の変数
        const animationLoops = new Map(); // track -> { startX, targetX, startTime, firstSetWidth, isRunning }
         try {
             const parsed = JSON.parse(configElement.textContent);
             currentPhotos = Array.isArray(parsed.photos) ? parsed.photos.slice() : [];
             currentPhotoUrls = Array.isArray(parsed.photoUrls) ? parsed.photoUrls.slice() : [];
             topPhotos = Array.isArray(parsed.topPhotos) ? parsed.topPhotos.slice() : [];
             topPhotoUrls = Array.isArray(parsed.topPhotoUrls) ? parsed.topPhotoUrls.slice() : [];
             recentPhotos = Array.isArray(parsed.recentPhotos) ? parsed.recentPhotos.slice() : [];
             recentPhotoUrls = Array.isArray(parsed.recentPhotoUrls) ? parsed.recentPhotoUrls.slice() : [];
        } catch (e) {
             console.warn('Failed to parse slideshow config:', e);
            currentPhotos = [];
             currentPhotoUrls = [];
             topPhotos = [];
             topPhotoUrls = [];
             recentPhotos = [];
             recentPhotoUrls = [];
        }

        let lastPhotoCount = currentPhotos.length;
        let refreshTimer = null;
         let fetchInProgress = false;
        let lastStorageTimestamp = Date.now();
         let topTrack = document.getElementById('topTrack');
         const middleTrack = document.getElementById('middleTrack');
        let pollTimer = null;
        let currentPollInterval = MIN_POLL_INTERVAL;

        function scheduleNextPoll(delay = currentPollInterval) {
            if (pollTimer) {
                clearTimeout(pollTimer);
            }
            pollTimer = setTimeout(() => fetchLatestPhotos(), Math.max(0, delay));
        }

        function resetPollIntervalToMinimum() {
            currentPollInterval = MIN_POLL_INTERVAL;
        }

        function backoffPollInterval() {
            currentPollInterval = Math.min(MAX_POLL_INTERVAL, Math.round(currentPollInterval * POLL_GROWTH_FACTOR));
        }

        function requestImmediateRefresh(silent = false) {
            resetPollIntervalToMinimum();
            fetchLatestPhotos(silent);
        }

        function scheduleRefresh() {
            if (refreshTimer) {
                return;
            }
            refreshTimer = setTimeout(() => {
                refreshTimer = null;
                requestImmediateRefresh();
            }, 600);
        }

        try {
            const channel = new BroadcastChannel('photo_upload');
            channel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'photo_uploaded') {
                    scheduleRefresh();
                }
            });
        } catch (e) {
            console.log('BroadcastChannel not supported in this browser.');
        }

        setInterval(() => {
            try {
                const stored = localStorage.getItem('last_uploaded_photo');
                if (!stored) {
                    return;
                }
                const data = JSON.parse(stored);
                if (!data || !data.filename || !data.timestamp) {
                    return;
                }
                if (data.timestamp > lastStorageTimestamp && !currentPhotos.includes(data.filename)) {
                    lastStorageTimestamp = data.timestamp;
                    requestImmediateRefresh();
                }
            } catch (error) {
            }
        }, 2000);

        function fetchLatestPhotos(silent = false) {
            if (fetchInProgress) {
                return;
            }
            fetchInProgress = true;
            fetch('/api/photos')
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Network error');
                    }
                    return response.json();
                })
                .then((data) => {
                    if (!data || !Array.isArray(data.photos)) {
                        return;
                    }
                    const hasUpdates = handlePhotoListUpdate(data);
                    if (hasUpdates) {
                        resetPollIntervalToMinimum();
                    } else {
                        backoffPollInterval();
                    }
                })
                .catch(() => {
                    backoffPollInterval();
                })
                .finally(() => {
                    fetchInProgress = false;
                    if (!silent) {
                        scheduleNextPoll();
                    }
                });
        }

        function buildPhotoUrl(filename) {
            if (!filename) {
                return '';
            }
            return `${uploadsBaseUrl}${encodeURIComponent(filename)}`;
        }

        function arraysEqual(a, b) {
            if (!Array.isArray(a) || !Array.isArray(b)) {
                return false;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i += 1) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }

        function renderRecentTrack(preservePosition = false) {
            if (!middleTrack) {
                return;
            }
            
            // 位置を保持する場合、現在の位置を取得（DOMをクリアする前に）
            let currentTranslateX = 0;
            let oldFirstSetWidth = 0;
            if (preservePosition) {
                // まず、実際のtransform値から現在の位置を取得（最も正確）
                const computedStyle = window.getComputedStyle(middleTrack);
                const currentTransform = computedStyle.transform;
                if (currentTransform && currentTransform !== 'none') {
                    const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                    if (matrix) {
                        const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                        currentTranslateX = values[4] || 0;
                    }
                }
                oldFirstSetWidth = middleTrack.dataset.firstSetWidth ? parseFloat(middleTrack.dataset.firstSetWidth) : 0;
                
                // アニメーションループを停止
                const loop = animationLoops.get(middleTrack);
                if (loop && loop.isRunning) {
                    loop.isRunning = false;
                }
                
                console.log('[DEBUG renderRecentTrack] Preserving position from transform:', currentTranslateX, 'oldFirstSetWidth:', oldFirstSetWidth);
                
                // 位置が取得できなかった場合は、位置を保持しない
                if (currentTranslateX === 0 && oldFirstSetWidth === 0) {
                    console.log('[DEBUG renderRecentTrack] Could not get position, not preserving');
                    preservePosition = false;
                }
            } else {
                console.log('[DEBUG renderRecentTrack] Not preserving position (preservePosition = false)');
            }
            
            middleTrack.innerHTML = '';
            const firstSetLength = recentPhotos.length;
            const shouldLoop = firstSetLength >= 10;
            middleTrack.dataset.firstSetLength = firstSetLength;
            const enableLoop = firstSetLength > 0;
            middleTrack.dataset.loopEnabled = enableLoop ? '1' : '0';

            if (!firstSetLength) {
                middleTrack.classList.remove('animate');
                middleTrack.style.animation = 'none';
                return;
            }

            const fragment = document.createDocumentFragment();
            recentPhotos.forEach((photo, index) => {
                const url = recentPhotoUrls[index] || buildPhotoUrl(photo);
                fragment.appendChild(createImageElement(url, photo));
            });
            middleTrack.appendChild(fragment);

            const duplicateFragment = document.createDocumentFragment();
            recentPhotos.forEach((photo, index) => {
                const url = recentPhotoUrls[index] || buildPhotoUrl(photo);
                duplicateFragment.appendChild(createImageElement(url, photo));
            });
            middleTrack.appendChild(duplicateFragment);
            
            // 画像の読み込みを待つ（エラー時も処理を続行）
            const imageLoadPromises = Array.from(middleTrack.querySelectorAll('img')).map((img, index) => {
                if (img.complete && img.naturalWidth > 0) {
                    return Promise.resolve(true);
                }
                return new Promise((resolve) => {
                    let resolved = false;
                    const resolveOnce = (success) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(success);
                        }
                    };
                    img.addEventListener('load', () => resolveOnce(true), { once: true });
                    img.addEventListener('error', () => {
                        console.warn('[DEBUG renderRecentTrack] Image load error:', img.src);
                        resolveOnce(false);
                    }, { once: true });
                    // タイムアウトを5秒に延長
                    setTimeout(() => {
                        if (!resolved) {
                            console.warn('[DEBUG renderRecentTrack] Image load timeout:', img.src);
                            resolveOnce(false);
                        }
                    }, 5000);
                });
            });

            Promise.all(imageLoadPromises).then((results) => {
                const successCount = results.filter(r => r === true).length;
                const totalCount = results.length;
                console.log('[DEBUG renderRecentTrack] Image load results:', { successCount, totalCount });
                
                // 少なくとも1つの画像が読み込まれていることを確認
                if (totalCount === 0) {
                    console.error('[DEBUG renderRecentTrack] No images to load');
                    return;
                }
                
                requestAnimationFrame(() => {
                    if (middleTrack.children.length > 0) {
                        // 読み込まれた画像の幅を取得（エラー画像はスキップ）
                        let firstImageWidth = 0;
                        let retryCount = 0;
                        const maxRetries = 10;
                        
                        const tryGetWidth = () => {
                            const firstImg = middleTrack.children[0];
                            if (firstImg && firstImg.tagName === 'IMG') {
                                firstImageWidth = firstImg.getBoundingClientRect().width;
                                // 画像が読み込まれているか確認
                                if (firstImg.complete && firstImg.naturalWidth > 0 && firstImageWidth > 0) {
                                    const firstSetWidth = firstImageWidth * firstSetLength;
                                    middleTrack.dataset.firstSetWidth = firstSetWidth.toString();
                                    handleAnimationStart(middleTrack, firstSetWidth, preservePosition, oldFirstSetWidth, currentTranslateX);
                                    return;
                                }
                            }
                            
                            // リトライ
                            retryCount++;
                            if (retryCount < maxRetries) {
                                setTimeout(tryGetWidth, 100);
                            } else {
                                console.error('[DEBUG renderRecentTrack] Failed to get image width after retries');
                                // フォールバック: アニメーションを再開
                                restartTrackAnimation(middleTrack);
                            }
                        };
                        
                        tryGetWidth();
                    } else {
                        console.error('[DEBUG renderRecentTrack] No children in track');
                        restartTrackAnimation(middleTrack);
                    }
                });
            });
        }
        
        function startJavaScriptAnimation(track, firstSetWidth, startX = 0) {
            if (!track || firstSetWidth <= 0) {
                console.log('[DEBUG startJavaScriptAnimation] Invalid parameters', { track: !!track, firstSetWidth });
                return;
            }
            
            // 既存のアニメーションループを停止
            const existingLoop = animationLoops.get(track);
            if (existingLoop) {
                if (existingLoop.isRunning) {
                    existingLoop.isRunning = false;
                    console.log('[DEBUG startJavaScriptAnimation] Stopped existing loop');
                }
                // 既存のフレームIDをキャンセル
                if (existingLoop.frameId) {
                    try {
                        cancelAnimationFrame(existingLoop.frameId);
                    } catch (e) {
                        // 無視
                    }
                }
            }
            
            // 新しいアニメーションループを開始（無限ループを保証）
            const loop = {
                startX: startX,
                targetX: startX - firstSetWidth,
                startTime: performance.now(),
                firstSetWidth: firstSetWidth,
                isRunning: true,
                lastFrameTime: performance.now(),
                frameId: null,
                cycleCount: 0 // サイクル数を追跡（デバッグ用）
            };
            animationLoops.set(track, loop);
            
            console.log('[DEBUG startJavaScriptAnimation] Starting infinite animation', {
                startX,
                targetX: loop.targetX,
                firstSetWidth,
                trackId: track.id
            });
            
            // 無限ループを保証するアニメーションフレーム関数
            function animateFrame() {
                // アニメーションが停止している場合は即座に再開を試みる
                if (!loop.isRunning || !track.classList.contains('animate')) {
                    if (track.classList.contains('animate') && track.dataset.loopEnabled === '1') {
                        const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
                        if (firstSetWidth > 0) {
                            const computedStyle = window.getComputedStyle(track);
                            const currentTransform = computedStyle.transform;
                            let restartX = 0;
                            if (currentTransform && currentTransform !== 'none') {
                                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                                if (matrix) {
                                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                                    restartX = values[4] || 0;
                                }
                            }
                            console.log('[DEBUG animateFrame] Loop stopped, restarting', { trackId: track.id, restartX, isRunning: loop.isRunning });
                            loop.isRunning = false;
                            startJavaScriptAnimation(track, firstSetWidth, restartX);
                        }
                    }
                    return;
                }
                
                try {
                    const currentLoop = animationLoops.get(track);
                    if (!currentLoop || currentLoop !== loop) {
                        // ループが置き換えられた場合は終了
                        return;
                    }
                    
                    const currentTime = performance.now();
                    
                    // フレームが更新されているかチェック（1秒以上更新されていない場合は再開）
                    if (loop.lastFrameTime && (currentTime - loop.lastFrameTime > 1000)) {
                        console.log('[DEBUG animateFrame] Frame not updating, restarting', { trackId: track.id, timeSinceLastFrame: currentTime - loop.lastFrameTime });
                        if (track.classList.contains('animate') && track.dataset.loopEnabled === '1') {
                            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
                            if (firstSetWidth > 0) {
                                const computedStyle = window.getComputedStyle(track);
                                const currentTransform = computedStyle.transform;
                                let restartX = 0;
                                if (currentTransform && currentTransform !== 'none') {
                                    const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                                    if (matrix) {
                                        const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                                        restartX = values[4] || 0;
                                    }
                                }
                                // 現在のループを停止してから再開
                                loop.isRunning = false;
                                startJavaScriptAnimation(track, firstSetWidth, restartX);
                                return;
                            }
                        }
                    }
                    
                    // このチェックは既に最初に行われているので、ここでは削除
                    
                    loop.lastFrameTime = currentTime;
                    
                    // 経過時間を計算
                    const elapsed = (currentTime - loop.startTime) / 1000;
                    // レーンに応じたアニメーション時間を取得（firstSetWidthに基づいて計算）
                    const animationDuration = getAnimationDuration(track, loop.firstSetWidth);
                    // 進捗を0-1の範囲に正規化（無限ループを保証）
                    let progress = (elapsed / animationDuration) % 1;
                    
                    // 完了したサイクル数を計算
                    const completedCycles = Math.floor(elapsed / animationDuration);
                    
                    // 現在の位置を計算（常に0-1の進捗で計算）
                    // サイクルが完了した場合も、進捗を正規化して計算することで無限ループを保証
                    let currentX = loop.startX + (loop.targetX - loop.startX) * progress;
                    track.style.transform = `translateX(${currentX}px)`;
                    
                    // サイクルが完了した場合（progressが0に近い、または1に近い場合）、
                    // startTimeをリセットして数値の精度を保つ（無限ループを保証）
                    if (progress < 0.01 && completedCycles > 0) {
                        // 現在の位置を基準に、次のサイクルを開始
                        // 位置をリセットせず、startTimeのみをリセット
                        loop.startX = currentX;
                        loop.targetX = currentX - loop.firstSetWidth;
                        // startTimeを現在の時刻にリセット
                        loop.startTime = currentTime;
                        // サイクル数を更新（デバッグ用）
                        loop.cycleCount = (loop.cycleCount || 0) + completedCycles;
                    }
                    
                    // 次のフレームをスケジュール（無限ループを保証）
                    // 既存のフレームIDをキャンセル（二重スケジュールを防ぐ）
                    if (loop.frameId !== null && loop.frameId !== undefined) {
                        try {
                            cancelAnimationFrame(loop.frameId);
                        } catch (e) {
                            // 無視
                        }
                    }
                    
                    // requestAnimationFrameを確実に呼び出す（無限ループを保証）
                    // エラーが発生しても、必ず次のフレームをスケジュールする
                    try {
                        loop.frameId = requestAnimationFrame(animateFrame);
                        // requestAnimationFrameが失敗した場合のフォールバック
                        if (!loop.frameId || loop.frameId === 0) {
                            console.warn('[DEBUG] requestAnimationFrame returned invalid ID, using setTimeout', { trackId: track.id });
                            loop.frameId = null;
                            // setTimeoutで代替（確実に次のフレームをスケジュール）
                            setTimeout(() => {
                                const currentLoop = animationLoops.get(track);
                                if (currentLoop && currentLoop === loop && currentLoop.isRunning && track.classList.contains('animate')) {
                                    animateFrame();
                                }
                            }, 16);
                        }
                    } catch (e) {
                        console.error('[DEBUG] Error scheduling next frame', e);
                        loop.frameId = null;
                        // エラーが発生しても、setTimeoutで代替（無限ループを保証）
                        setTimeout(() => {
                            const currentLoop = animationLoops.get(track);
                            if (currentLoop && currentLoop === loop && currentLoop.isRunning && track.classList.contains('animate')) {
                                animateFrame();
                            }
                        }, 16);
                    }
                } catch (error) {
                    console.error('[DEBUG animateFrame] Error:', error);
                    // エラーが発生した場合も、アニメーションを再開
                    if (track.classList.contains('animate') && track.dataset.loopEnabled === '1') {
                        const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
                        if (firstSetWidth > 0) {
                            const computedStyle = window.getComputedStyle(track);
                            const currentTransform = computedStyle.transform;
                            let restartX = 0;
                            if (currentTransform && currentTransform !== 'none') {
                                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                                if (matrix) {
                                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                                    restartX = values[4] || 0;
                                }
                            }
                            setTimeout(() => {
                                startJavaScriptAnimation(track, firstSetWidth, restartX);
                            }, 100);
                        }
                    }
                }
            }
            
            track.classList.add('animate');
            track.style.animation = 'none';
            // 開始位置を設定（重要：これがないと位置がリセットされる）
            track.style.transform = `translateX(${startX}px)`;
            console.log('[DEBUG startJavaScriptAnimation] Set initial transform:', startX);
            loop.frameId = requestAnimationFrame(animateFrame);
        }
        
        function handleAnimationStart(track, firstSetWidth, preservePosition, oldFirstSetWidth, currentTranslateX) {
            if (preservePosition && oldFirstSetWidth > 0 && currentTranslateX !== 0 && firstSetWidth > 0) {
                // 位置を保持する場合、現在の位置を調整
                // 直接比率で調整（より正確で、ズレが少ない）
                const adjustedTranslateX = (currentTranslateX * firstSetWidth) / oldFirstSetWidth;
                console.log('[DEBUG handleAnimationStart] Preserving position:', adjustedTranslateX, 'from', currentTranslateX, 'oldWidth:', oldFirstSetWidth, 'newWidth:', firstSetWidth);
                // 位置が0に近い場合は、位置を保持しない（初期化時など）
                if (Math.abs(adjustedTranslateX) < 10) {
                    console.log('[DEBUG handleAnimationStart] Position too close to 0, starting from 0');
                    startJavaScriptAnimation(track, firstSetWidth, 0);
                } else {
                    startJavaScriptAnimation(track, firstSetWidth, adjustedTranslateX);
                }
            } else {
                // 位置を保持しない場合、最初から開始
                startJavaScriptAnimation(track, firstSetWidth, 0);
            }
        }

        function renderTopTrack() {
            if (!topPhotos.length) {
                if (topTrack) {
                    topTrack.parentElement.remove();
                    topTrack = null;
                    document.body.classList.add('single-lane');
                }
                return;
            }

            if (!topTrack) {
                insertTopLaneSkeleton();
                topTrack = document.getElementById('topTrack');
                // renderRecentTrackは呼ばない（位置をリセットしない）
            }

            if (!topTrack) {
                return;
            }

            document.body.classList.remove('single-lane');

            topTrack.innerHTML = '';
            const firstSetLength = topPhotos.length;
            topTrack.dataset.firstSetLength = firstSetLength;
            topTrack.dataset.loopEnabled = '1';

            const fragment = document.createDocumentFragment();
            topPhotos.forEach((photo, index) => {
                const url = topPhotoUrls[index] || buildPhotoUrl(photo);
                fragment.appendChild(createImageElement(url, photo));
            });
            topTrack.appendChild(fragment);

            const duplicateFragment = document.createDocumentFragment();
            topPhotos.forEach((photo, index) => {
                const url = topPhotoUrls[index] || buildPhotoUrl(photo);
                duplicateFragment.appendChild(createImageElement(url, photo));
            });
            topTrack.appendChild(duplicateFragment);
            
            // 画像の読み込みを待つ（エラー時も処理を続行）
            const imageLoadPromises = Array.from(topTrack.querySelectorAll('img')).map((img, index) => {
                if (img.complete && img.naturalWidth > 0) {
                    return Promise.resolve(true);
                }
                return new Promise((resolve) => {
                    let resolved = false;
                    const resolveOnce = (success) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(success);
                        }
                    };
                    img.addEventListener('load', () => resolveOnce(true), { once: true });
                    img.addEventListener('error', () => {
                        console.warn('[DEBUG renderTopTrack] Image load error:', img.src);
                        resolveOnce(false);
                    }, { once: true });
                    // タイムアウトを5秒に延長
                    setTimeout(() => {
                        if (!resolved) {
                            console.warn('[DEBUG renderTopTrack] Image load timeout:', img.src);
                            resolveOnce(false);
                        }
                    }, 5000);
                });
            });

            Promise.all(imageLoadPromises).then((results) => {
                const successCount = results.filter(r => r === true).length;
                const totalCount = results.length;
                console.log('[DEBUG renderTopTrack] Image load results:', { successCount, totalCount });
                
                // 少なくとも1つの画像が読み込まれていることを確認
                if (totalCount === 0) {
                    console.error('[DEBUG renderTopTrack] No images to load');
                    return;
                }
                
                requestAnimationFrame(() => {
                    if (topTrack && topTrack.children.length > 0) {
                        // 読み込まれた画像の幅を取得（エラー画像はスキップ）
                        let firstImageWidth = 0;
                        let retryCount = 0;
                        const maxRetries = 10;
                        
                        const tryGetWidth = () => {
                            const firstImg = topTrack.children[0];
                            if (firstImg && firstImg.tagName === 'IMG') {
                                firstImageWidth = firstImg.getBoundingClientRect().width;
                                // 画像が読み込まれているか確認
                                if (firstImg.complete && firstImg.naturalWidth > 0 && firstImageWidth > 0) {
                                    const firstSetWidth = firstImageWidth * firstSetLength;
                                    topTrack.dataset.firstSetWidth = firstSetWidth.toString();
                                    restartTrackAnimation(topTrack);
                                    return;
                                }
                            }
                            
                            // リトライ
                            retryCount++;
                            if (retryCount < maxRetries) {
                                setTimeout(tryGetWidth, 100);
                            } else {
                                console.error('[DEBUG renderTopTrack] Failed to get image width after retries');
                                // フォールバック: アニメーションを再開
                                restartTrackAnimation(topTrack);
                            }
                        };
                        
                        tryGetWidth();
                    } else {
                        console.error('[DEBUG renderTopTrack] No children in track');
                        restartTrackAnimation(topTrack);
                    }
                });
            });
        }

        function getCurrentAnimationProgress(track) {
            if (!track || !track.classList.contains('animate')) {
                return 0;
            }
            const computedStyle = window.getComputedStyle(track);
            const transform = computedStyle.transform;
            if (!transform || transform === 'none') {
                return 0;
            }
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (!matrix) {
                return 0;
            }
            const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
            const translateX = values[4] || 0;
            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth === 0) {
                return 0;
            }
            const progress = Math.abs(translateX) / firstSetWidth;
            return progress % 1;
        }

        function smoothAddNewPhoto(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            console.log('[DEBUG smoothAddNewPhoto] Start');
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: track or arrays invalid');
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                console.log('[DEBUG smoothAddNewPhoto] Failed: loop not enabled', track.dataset.loopEnabled);
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: empty arrays', prevPhotos.length, nextPhotos.length);
                return false;
            }
            if (nextPhotos.length !== prevPhotos.length + 1) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: length mismatch', prevPhotos.length, nextPhotos.length);
                return false;
            }
            for (let i = 0; i < prevPhotos.length; i += 1) {
                if (nextPhotos[i] !== prevPhotos[i]) {
                    console.log('[DEBUG smoothAddNewPhoto] Failed: photo order changed at index', i, prevPhotos[i], nextPhotos[i]);
                    return false;
                }
            }
            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: firstSetLength mismatch', firstSetLength, prevPhotos.length);
                return false;
            }

            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth === 0) {
                const firstImageWidth = track.children[0] ? track.children[0].getBoundingClientRect().width : 0;
                if (firstImageWidth === 0) {
                    console.log('[DEBUG smoothAddNewPhoto] Failed: cannot get image width');
                    return false;
                }
                const calculatedWidth = firstImageWidth * firstSetLength;
                track.dataset.firstSetWidth = calculatedWidth.toString();
                console.log('[DEBUG smoothAddNewPhoto] Calculated width, returning false to retry');
                return false;
            }
            
            console.log('[DEBUG smoothAddNewPhoto] All checks passed, proceeding with photo addition');

            // 現在のアニメーション進行状況を取得
            // アニメーションを一時停止してから位置を取得
            track.style.animationPlayState = 'paused';
            const computedStyle = window.getComputedStyle(track);
            const currentTransform = computedStyle.transform;
            let currentTranslateX = 0;
            
            if (currentTransform && currentTransform !== 'none') {
                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                if (matrix) {
                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                    currentTranslateX = values[4] || 0;
                }
            }
            
            // 現在の位置が取得できない場合は、進行状況から計算
            if (currentTranslateX === 0 && track.classList.contains('animate')) {
                const currentProgress = getCurrentAnimationProgress(track);
                currentTranslateX = -(currentProgress * firstSetWidth);
                console.log('[DEBUG smoothAddNewPhoto] Calculated position from progress:', currentProgress, currentTranslateX);
            }
            
            console.log('[DEBUG smoothAddNewPhoto] Current position:', currentTranslateX, 'firstSetWidth:', firstSetWidth);
            
            // アニメーションを完全に停止（クラスを削除）
            track.classList.remove('animate');
            track.style.animation = 'none';
            track.style.transform = `translateX(${currentTranslateX}px)`;
            void track.offsetWidth; // リフローを強制

            // 新しい写真を追加（最初のセットの最後に追加）
            const newPrimary = createImageElement(newUrl, newPhoto);
            const duplicateIndex = firstSetLength;
            const insertBeforeNode = track.children[duplicateIndex] || null;
            track.insertBefore(newPrimary, insertBeforeNode);

            // 2つ目のセットの最後にも追加
            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            track.dataset.firstSetLength = nextPhotos.length;

            // 画像の読み込みを待ってからアニメーションを再開（エラー時も処理を続行）
            const imageLoadPromises = [newPrimary, newDuplicate].map((img, index) => {
                if (img.complete && img.naturalWidth > 0) {
                    return Promise.resolve(true);
                }
                return new Promise((resolve) => {
                    let resolved = false;
                    const resolveOnce = (success) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(success);
                        }
                    };
                    img.addEventListener('load', () => resolveOnce(true), { once: true });
                    img.addEventListener('error', () => {
                        console.warn('[DEBUG smoothAddNewPhoto] Image load error:', img.src);
                        resolveOnce(false);
                    }, { once: true });
                    // タイムアウトを5秒に延長
                    setTimeout(() => {
                        if (!resolved) {
                            console.warn('[DEBUG smoothAddNewPhoto] Image load timeout:', img.src);
                            resolveOnce(false);
                        }
                    }, 5000);
                });
            });

            Promise.all(imageLoadPromises).then((results) => {
                const successCount = results.filter(r => r === true).length;
                const totalCount = results.length;
                console.log('[DEBUG smoothAddNewPhoto] Image load results:', { successCount, totalCount });
                
                requestAnimationFrame(() => {
                    // 読み込まれた画像の幅を取得（エラー画像はスキップ）
                    let firstImageWidth = 0;
                    let retryCount = 0;
                    const maxRetries = 10;
                    
                    const tryGetWidth = () => {
                        const firstImg = track.children[0];
                        if (firstImg && firstImg.tagName === 'IMG') {
                            firstImageWidth = firstImg.getBoundingClientRect().width;
                            // 画像が読み込まれているか確認
                            if (firstImg.complete && firstImg.naturalWidth > 0 && firstImageWidth > 0) {
                                const newFirstSetWidth = firstImageWidth * nextPhotos.length;
                                track.dataset.firstSetWidth = newFirstSetWidth.toString();
                                
                                // 現在の位置を新しい幅に合わせて調整
                                const adjustedTranslateX = (currentTranslateX * newFirstSetWidth) / firstSetWidth;
                                
                                // 現在の位置を保持したまま、JavaScriptでアニメーションを制御
                                let animationStartTime = performance.now();
                                let animationStartX = adjustedTranslateX;
                                const targetX = adjustedTranslateX - newFirstSetWidth; // 1サイクル分進める
                                
                                // アニメーション関数
                                function animateFrame() {
                                    if (!track.classList.contains('animate')) {
                                        return;
                                    }
                                    const elapsed = (performance.now() - animationStartTime) / 1000;
                                    const animationDuration = getAnimationDuration(track, newFirstSetWidth);
                                    const progress = Math.min(elapsed / animationDuration, 1);
                                    const currentX = animationStartX + (targetX - animationStartX) * progress;
                                    track.style.transform = `translateX(${currentX}px)`;
                                    
                                    if (progress < 1) {
                                        requestAnimationFrame(animateFrame);
                                    } else {
                                        // 1サイクル完了したら、現在の位置から通常のCSSアニメーションに切り替え
                                        const finalX = currentX % (-newFirstSetWidth);
                                        track.style.transform = `translateX(${finalX}px)`;
                                        track.style.animation = `scroll ${animationDuration}s linear infinite`;
                                        const remainingProgress = Math.abs(finalX) / newFirstSetWidth;
                                        const delay = -remainingProgress * animationDuration;
                                        track.style.animationDelay = `${delay}s`;
                                        setTimeout(() => {
                                            if (track.classList.contains('animate')) {
                                                track.style.animationDelay = '0s';
                                            }
                                        }, (1 - remainingProgress) * animationDuration * 1000);
                                    }
                                }
                                
                                track.classList.add('animate');
                                track.style.animation = 'none';
                                requestAnimationFrame(animateFrame);
                                return;
                            }
                        }
                        
                        // リトライ
                        retryCount++;
                        if (retryCount < maxRetries) {
                            setTimeout(tryGetWidth, 100);
                        } else {
                            console.error('[DEBUG smoothAddNewPhoto] Failed to get image width after retries');
                            // フォールバック: アニメーションを再開
                            restartTrackAnimation(track, true);
                        }
                    };
                    
                    tryGetWidth();
                });
            });

            return true;
        }

        function smoothAddNewPhotoAtEnd(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            console.log('[DEBUG smoothAddNewPhotoAtEnd] Start');
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: track or arrays invalid');
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: loop not enabled', track.dataset.loopEnabled);
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: empty arrays', prevPhotos.length, nextPhotos.length);
                return false;
            }
            if (prevPhotos.length !== nextPhotos.length) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: length mismatch', prevPhotos.length, nextPhotos.length);
                return false;
            }

            // 最初のN-1個の要素が一致し、最後の要素が新しい写真であることを確認
            const prevPhotosMatch = prevPhotos.slice(0, -1).every((photo, i) => photo === nextPhotos[i]);
            const newPhotoAtEnd = nextPhotos[nextPhotos.length - 1] !== prevPhotos[prevPhotos.length - 1];
            
            console.log('[DEBUG smoothAddNewPhotoAtEnd] Checking conditions:', {
                prevPhotosMatch,
                newPhotoAtEnd,
                prevLast: prevPhotos[prevPhotos.length - 1],
                nextLast: nextPhotos[nextPhotos.length - 1],
                prevFirst: prevPhotos[0],
                nextFirst: nextPhotos[0],
                prevSlice: prevPhotos.slice(0, -1),
                nextSlice: nextPhotos.slice(0, -1)
            });
            
            if (!prevPhotosMatch || !newPhotoAtEnd) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: not a simple end addition', {
                    prevPhotosMatch,
                    newPhotoAtEnd,
                    prevLast: prevPhotos[prevPhotos.length - 1],
                    nextLast: nextPhotos[nextPhotos.length - 1]
                });
                return false;
            }

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: firstSetLength mismatch', firstSetLength, prevPhotos.length);
                return false;
            }

            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth === 0) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: firstSetWidth is 0');
                return false;
            }

            // 現在の位置を取得
            track.style.animationPlayState = 'paused';
            const computedStyle = window.getComputedStyle(track);
            const currentTransform = computedStyle.transform;
            let currentTranslateX = 0;
            
            if (currentTransform && currentTransform !== 'none') {
                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                if (matrix) {
                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                    currentTranslateX = values[4] || 0;
                }
            }
            
            if (currentTranslateX === 0 && track.classList.contains('animate')) {
                const currentProgress = getCurrentAnimationProgress(track);
                currentTranslateX = -(currentProgress * firstSetWidth);
            }
            
            console.log('[DEBUG smoothAddNewPhotoAtEnd] Current position:', currentTranslateX, 'firstSetWidth:', firstSetWidth);

            // アニメーションを停止
            track.classList.remove('animate');
            track.style.animation = 'none';
            track.style.transform = `translateX(${currentTranslateX}px)`;
            void track.offsetWidth;

            // 最後の要素（古い最後の写真）を削除し、新しい写真を追加
            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            // 最初のセットの最後の要素を削除
            const lastPrimaryIndex = firstSetLength - 1;
            const lastPrimary = track.children[lastPrimaryIndex];
            if (lastPrimary) {
                track.removeChild(lastPrimary);
            }

            // 2つ目のセットの最後の要素を削除
            const lastDuplicateIndex = firstSetLength * 2 - 1;
            const lastDuplicate = track.children[lastDuplicateIndex];
            if (lastDuplicate) {
                track.removeChild(lastDuplicate);
            }

            // 新しい写真を最初のセットの最後に追加
            const newPrimary = createImageElement(newUrl, newPhoto);
            const insertBeforeNode = track.children[firstSetLength - 1] || null;
            if (insertBeforeNode) {
                track.insertBefore(newPrimary, insertBeforeNode.nextSibling);
            } else {
                track.appendChild(newPrimary);
            }

            // 新しい写真を2つ目のセットの最後に追加
            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            // 画像の読み込みを待つ（エラー時も処理を続行）
            const imageLoadPromises = [newPrimary, newDuplicate].map((img, index) => {
                if (img.complete && img.naturalWidth > 0) {
                    return Promise.resolve(true);
                }
                return new Promise((resolve) => {
                    let resolved = false;
                    const resolveOnce = (success) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(success);
                        }
                    };
                    img.addEventListener('load', () => resolveOnce(true), { once: true });
                    img.addEventListener('error', () => {
                        console.warn('[DEBUG smoothAddNewPhotoAtEnd] Image load error:', img.src);
                        resolveOnce(false);
                    }, { once: true });
                    // タイムアウトを5秒に延長
                    setTimeout(() => {
                        if (!resolved) {
                            console.warn('[DEBUG smoothAddNewPhotoAtEnd] Image load timeout:', img.src);
                            resolveOnce(false);
                        }
                    }, 5000);
                });
            });

            Promise.all(imageLoadPromises).then((results) => {
                const successCount = results.filter(r => r === true).length;
                const totalCount = results.length;
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Image load results:', { successCount, totalCount });
                
                requestAnimationFrame(() => {
                    // 読み込まれた画像の幅を取得（エラー画像はスキップ）
                    let firstImageWidth = 0;
                    let retryCount = 0;
                    const maxRetries = 10;
                    
                    const tryGetWidth = () => {
                        const firstImg = track.children[0];
                        if (firstImg && firstImg.tagName === 'IMG') {
                            firstImageWidth = firstImg.getBoundingClientRect().width;
                            // 画像が読み込まれているか確認
                            if (firstImg.complete && firstImg.naturalWidth > 0 && firstImageWidth > 0) {
                                const newFirstSetWidth = firstImageWidth * nextPhotos.length;
                                track.dataset.firstSetWidth = newFirstSetWidth.toString();
                                
                                // 現在の位置を新しい幅に合わせて調整
                                const adjustedTranslateX = (currentTranslateX * newFirstSetWidth) / firstSetWidth;
                                
                                // 現在の位置を保持したまま、JavaScriptでアニメーションを制御
                                let animationStartTime = performance.now();
                                let animationStartX = adjustedTranslateX;
                                const targetX = adjustedTranslateX - newFirstSetWidth;
                                
                                function animateFrame() {
                                    if (!track.classList.contains('animate')) {
                                        return;
                                    }
                                    const elapsed = (performance.now() - animationStartTime) / 1000;
                                    const animationDuration = getAnimationDuration(track, newFirstSetWidth);
                                    const progress = Math.min(elapsed / animationDuration, 1);
                                    const currentX = animationStartX + (targetX - animationStartX) * progress;
                                    track.style.transform = `translateX(${currentX}px)`;
                                    
                                    if (progress < 1) {
                                        requestAnimationFrame(animateFrame);
                                    } else {
                                        // 1サイクル完了したら、現在の位置から通常のCSSアニメーションに切り替え
                                        const finalX = currentX % (-newFirstSetWidth);
                                        track.style.transform = `translateX(${finalX}px)`;
                                        track.style.animation = `scroll ${animationDuration}s linear infinite`;
                                        const remainingProgress = Math.abs(finalX) / newFirstSetWidth;
                                        const delay = -remainingProgress * animationDuration;
                                        track.style.animationDelay = `${delay}s`;
                                        setTimeout(() => {
                                            if (track.classList.contains('animate')) {
                                                track.style.animationDelay = '0s';
                                            }
                                        }, (1 - remainingProgress) * animationDuration * 1000);
                                    }
                                }
                                
                                track.classList.add('animate');
                                track.style.animation = 'none';
                                requestAnimationFrame(animateFrame);
                                return;
                            }
                        }
                        
                        // リトライ
                        retryCount++;
                        if (retryCount < maxRetries) {
                            setTimeout(tryGetWidth, 100);
                        } else {
                            console.error('[DEBUG smoothAddNewPhotoAtEnd] Failed to get image width after retries');
                            // フォールバック: アニメーションを再開
                            restartTrackAnimation(track, true);
                        }
                    };
                    
                    tryGetWidth();
                });
            });

            return true;
        }

        function tryIncrementalShift(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            console.log('[DEBUG tryIncrementalShift] Start');
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                console.log('[DEBUG tryIncrementalShift] Failed: track or arrays invalid');
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                console.log('[DEBUG tryIncrementalShift] Failed: loop not enabled', track.dataset.loopEnabled);
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                console.log('[DEBUG tryIncrementalShift] Failed: empty arrays', prevPhotos.length, nextPhotos.length);
                return false;
            }
            if (prevPhotos.length !== nextPhotos.length) {
                console.log('[DEBUG tryIncrementalShift] Failed: length mismatch', prevPhotos.length, nextPhotos.length);
                return false;
            }

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                console.log('[DEBUG tryIncrementalShift] Failed: firstSetLength mismatch', firstSetLength, prevPhotos.length);
                return false;
            }

            for (let i = 0; i < nextPhotos.length - 1; i += 1) {
                if (nextPhotos[i] !== prevPhotos[i + 1]) {
                    console.log('[DEBUG tryIncrementalShift] Failed: photo order mismatch at index', i, 'next:', nextPhotos[i], 'prev[i+1]:', prevPhotos[i + 1]);
                    return false;
                }
            }
            console.log('[DEBUG tryIncrementalShift] All checks passed, proceeding with shift');

            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            const expectedChildCount = firstSetLength * 2;
            if (track.children.length !== expectedChildCount) {
                return false;
            }

            const primaryToRemove = track.children[0];
            if (!primaryToRemove) {
                return false;
            }
            track.removeChild(primaryToRemove);

            const duplicateIndex = firstSetLength - 1;
            const duplicateToRemove = track.children[duplicateIndex];
            if (!duplicateToRemove) {
                return false;
            }
            track.removeChild(duplicateToRemove);

            const newPrimary = createImageElement(newUrl, newPhoto);
            const insertBeforeNode = track.children[duplicateIndex] || null;
            track.insertBefore(newPrimary, insertBeforeNode);

            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            track.dataset.firstSetLength = nextPhotos.length;
            return true;
        }

        function handlePhotoListUpdate(payload) {
            const newPhotos = Array.isArray(payload.photos) ? payload.photos : [];
            const newPhotoUrls = Array.isArray(payload.photo_urls) ? payload.photo_urls : null;
            if (!Array.isArray(newPhotos)) {
                return false;
            }
            if (newPhotos.length < currentPhotos.length) {
                return true;
            }

            const hadAddition = newPhotos.length > currentPhotos.length;

            const prevRecentPhotos = recentPhotos.slice();
            const prevRecentPhotoUrls = recentPhotoUrls.slice();
            const prevTopPhotos = topPhotos.slice();
            const prevTopPhotoUrls = topPhotoUrls.slice();

            currentPhotos = newPhotos.slice();
            if (Array.isArray(newPhotoUrls)) {
                currentPhotoUrls = newPhotoUrls.slice();
            } else if (hadAddition) {
                currentPhotoUrls = currentPhotos.map(buildPhotoUrl);
            }

            const payloadRecentPhotos = Array.isArray(payload.recent_photos) ? payload.recent_photos : null;
            const payloadRecentPhotoUrls = Array.isArray(payload.recent_photo_urls) ? payload.recent_photo_urls : null;
            // 最新10投稿が2レーン目
            const newRecentPhotos = payloadRecentPhotos ? payloadRecentPhotos.slice() : currentPhotos.slice(0, 10);
            const newRecentPhotoUrls = payloadRecentPhotoUrls
                ? payloadRecentPhotoUrls.slice()
                : (Array.isArray(newPhotoUrls)
                    ? newPhotoUrls.slice(0, 10)
                    : newRecentPhotos.map(buildPhotoUrl));

            const recentChanged = !arraysEqual(newRecentPhotos, recentPhotos) || !arraysEqual(newRecentPhotoUrls, recentPhotoUrls);
            
            // recentPhotosの内容が変わった場合、写真が追加された可能性がある
            // 配列の内容が変わっているか確認（最初の要素や最後の要素が変わっている場合）
            const arraysCompletelyEqual = arraysEqual(newRecentPhotos, prevRecentPhotos) && arraysEqual(newRecentPhotoUrls, prevRecentPhotoUrls);
            const firstElementChanged = newRecentPhotos.length > 0 && prevRecentPhotos.length > 0 && newRecentPhotos[0] !== prevRecentPhotos[0];
            const lastElementChanged = newRecentPhotos.length > 0 && prevRecentPhotos.length > 0 && newRecentPhotos[newRecentPhotos.length - 1] !== prevRecentPhotos[prevRecentPhotos.length - 1];
            const hasNewPhotoInRecent = recentChanged && !arraysCompletelyEqual && (
                hadAddition || 
                firstElementChanged ||
                lastElementChanged ||
                (newRecentPhotos.length > 0 && !prevRecentPhotos.includes(newRecentPhotos[newRecentPhotos.length - 1]))
            );

            if (recentChanged) {
                let handled = false;
                console.log('[DEBUG] recentChanged:', {
                    prevLength: prevRecentPhotos.length,
                    newLength: newRecentPhotos.length,
                    hadAddition: hadAddition,
                    hasNewPhotoInRecent: hasNewPhotoInRecent,
                    condition1: newRecentPhotos.length === prevRecentPhotos.length + 1 && hadAddition,
                    condition2: newRecentPhotos.length === prevRecentPhotos.length && hadAddition,
                    prevFirst: prevRecentPhotos[0],
                    newFirst: newRecentPhotos[0],
                    prevLast: prevRecentPhotos[prevRecentPhotos.length - 1],
                    newLast: newRecentPhotos[newRecentPhotos.length - 1]
                });
                
                // ケース1: 配列の長さが1つ増える場合（10枚→11枚）
                if (newRecentPhotos.length === prevRecentPhotos.length + 1 && hadAddition) {
                    console.log('[DEBUG] Calling smoothAddNewPhoto (case 1: length increased)');
                    handled = smoothAddNewPhoto(
                        middleTrack,
                        prevRecentPhotos,
                        prevRecentPhotoUrls,
                        newRecentPhotos,
                        newRecentPhotoUrls
                    );
                    console.log('[DEBUG] smoothAddNewPhoto returned:', handled);
                }
                
                // ケース2: 配列の長さが同じで、内容がシフトしている場合（10枚→10枚、最初が削除され最後に追加）
                if (!handled && newRecentPhotos.length === prevRecentPhotos.length && hadAddition) {
                    console.log('[DEBUG] Trying tryIncrementalShift (case 2: same length, shifted)');
                    handled = tryIncrementalShift(
                        middleTrack,
                        prevRecentPhotos,
                        prevRecentPhotoUrls,
                        newRecentPhotos,
                        newRecentPhotoUrls
                    );
                    console.log('[DEBUG] tryIncrementalShift returned:', handled);
                }
                
                // ケース3: 配列の長さが同じで、新しい写真が最後に追加されている場合（位置を保持して追加）
                if (!handled && newRecentPhotos.length === prevRecentPhotos.length && hadAddition) {
                    console.log('[DEBUG] Trying smoothAddNewPhotoAtEnd (case 3: same length, new photo at end)');
                    // 新しい写真が最後に追加されているか確認
                    const newPhotoAtEnd = newRecentPhotos[newRecentPhotos.length - 1];
                    const prevPhotoAtEnd = prevRecentPhotos[prevRecentPhotos.length - 1];
                    const isNewPhotoAtEnd = newPhotoAtEnd !== prevPhotoAtEnd;
                    const prevPhotosMatch = prevRecentPhotos.slice(0, -1).every((photo, i) => photo === newRecentPhotos[i]);
                    
                    if (isNewPhotoAtEnd && prevPhotosMatch) {
                        console.log('[DEBUG] New photo is at the end, using smoothAddNewPhotoAtEnd');
                        handled = smoothAddNewPhotoAtEnd(
                            middleTrack,
                            prevRecentPhotos,
                            prevRecentPhotoUrls,
                            newRecentPhotos,
                            newRecentPhotoUrls
                        );
                        console.log('[DEBUG] smoothAddNewPhotoAtEnd returned:', handled);
                    }
                }
                
                recentPhotos = newRecentPhotos;
                recentPhotoUrls = newRecentPhotoUrls;
                if (!handled) {
                    // 位置を保持しようとする（新しい写真が追加された可能性がある場合）
                    // hasNewPhotoInRecentがtrueの場合、位置を保持（hadAdditionがfalseでも、recentPhotosの内容が変わっている場合は保持）
                    const shouldPreserve = hasNewPhotoInRecent && (newRecentPhotos.length >= prevRecentPhotos.length);
                    console.log('[DEBUG] Falling back to renderRecentTrack', {
                        hadAddition,
                        hasNewPhotoInRecent,
                        firstElementChanged,
                        lastElementChanged,
                        shouldPreserve,
                        prevLength: prevRecentPhotos.length,
                        newLength: newRecentPhotos.length,
                        prevFirst: prevRecentPhotos[0],
                        newFirst: newRecentPhotos[0],
                        prevLast: prevRecentPhotos[prevRecentPhotos.length - 1],
                        newLast: newRecentPhotos[newRecentPhotos.length - 1]
                    });
                    renderRecentTrack(shouldPreserve);
                }
            }

            const payloadTopPhotos = Array.isArray(payload.top_photos) ? payload.top_photos : null;
            const payloadTopPhotoUrls = Array.isArray(payload.top_photo_urls) ? payload.top_photo_urls : null;
            // 11枚目~30枚目が1レーン目
            const newTopPhotos = payloadTopPhotos ? payloadTopPhotos.slice() : currentPhotos.slice(10, 30);
            const newTopPhotoUrls = payloadTopPhotoUrls
                ? payloadTopPhotoUrls.slice()
                : (Array.isArray(newPhotoUrls)
                    ? newPhotoUrls.slice(10, 30)
                    : newTopPhotos.map(buildPhotoUrl));

            const topChanged = !arraysEqual(newTopPhotos, topPhotos) || !arraysEqual(newTopPhotoUrls, topPhotoUrls);

            if (topChanged) {
                let handled = false;
                if (newTopPhotos.length === prevTopPhotos.length + 1 && hadAddition) {
                    handled = smoothAddNewPhoto(
                        topTrack,
                        prevTopPhotos,
                        prevTopPhotoUrls,
                        newTopPhotos,
                        newTopPhotoUrls
                    );
                }
                if (!handled) {
                    handled = tryIncrementalShift(
                        topTrack,
                        prevTopPhotos,
                        prevTopPhotoUrls,
                        newTopPhotos,
                        newTopPhotoUrls
                    );
                }
                topPhotos = newTopPhotos;
                topPhotoUrls = newTopPhotoUrls;
                if (!handled) {
                    if (!topTrack && newTopPhotos.length) {
                        insertTopLaneSkeleton();
                    }
                    renderTopTrack();
                }
            }

            lastPhotoCount = currentPhotos.length;
            return hadAddition;
        }

        function createImageElement(url, filename) {
            const img = document.createElement('img');
            img.src = url || buildPhotoUrl(filename);
            img.alt = 'Photo';
            return img;
        }

        function initializeSlideshow() {
            const tracks = document.querySelectorAll('.slide-track');
            
            tracks.forEach((track) => {
                track.classList.add('init');
                
                const images = track.querySelectorAll('img');
                
                if (images.length === 0) {
                    return;
                }
                
                let loadedCount = 0;
                const totalImages = images.length;
                
                function checkAllLoaded() {
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        startAnimation(track);
                    }
                }
                
                images.forEach(img => {
                    if (img.complete) {
                        checkAllLoaded();
                    } else {
                        img.addEventListener('load', checkAllLoaded);
                        img.addEventListener('error', checkAllLoaded);
                    }
                });
                
                setTimeout(() => {
                    if (track.classList.contains('init')) {
                        startAnimation(track);
                    }
                }, 5000);
            });
        }
        
        function startAnimation(track) {
            if (track.dataset.loopEnabled !== '1') {
                track.classList.remove('animate');
                track.style.animation = 'none';
                const loop = animationLoops.get(track);
                if (loop) {
                    loop.isRunning = false;
                }
                return;
            }
            track.classList.remove('init');
            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth > 0) {
                startJavaScriptAnimation(track, firstSetWidth, 0);
            }
        }

        function restartTrackAnimation(track, preservePosition = false) {
            if (!track) {
                return;
            }
            if (track.dataset.loopEnabled !== '1') {
                track.classList.remove('animate');
                track.style.animation = 'none';
                const loop = animationLoops.get(track);
                if (loop) {
                    loop.isRunning = false;
                }
                return;
            }
            
            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth <= 0) {
                return;
            }
            
            let startX = 0;
            if (preservePosition) {
                const loop = animationLoops.get(track);
                if (loop && loop.isRunning) {
                    // 現在の位置を取得
                    const computedStyle = window.getComputedStyle(track);
                    const currentTransform = computedStyle.transform;
                    if (currentTransform && currentTransform !== 'none') {
                        const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                        if (matrix) {
                            const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                            startX = values[4] || 0;
                        }
                    }
                } else {
                    const currentProgress = getCurrentAnimationProgress(track);
                    startX = -(currentProgress * firstSetWidth);
                }
            }
            
            track.classList.remove('animate');
            track.classList.add('init');
            track.style.animation = 'none';
            void track.offsetWidth;
            startJavaScriptAnimation(track, firstSetWidth, startX);
        }
        
        window.addEventListener('load', function() {
            if (!topTrack && topPhotos.length) {
                insertTopLaneSkeleton();
            }
            renderTopTrack();
            renderRecentTrack();
            setTimeout(initializeSlideshow, 100);
            scheduleNextPoll();
        });
        
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                const tracks = document.querySelectorAll('.slide-track');
                tracks.forEach(track => {
                    if (track.dataset.loopEnabled === '1') {
                        const loop = animationLoops.get(track);
                        if (!loop || !loop.isRunning) {
                            // アニメーションが停止している場合は再開
                            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
                            if (firstSetWidth > 0) {
                                // 現在の位置を取得
                                const computedStyle = window.getComputedStyle(track);
                                const currentTransform = computedStyle.transform;
                                let startX = 0;
                                if (currentTransform && currentTransform !== 'none') {
                                    const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                                    if (matrix) {
                                        const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                                        startX = values[4] || 0;
                                    }
                                }
                                startJavaScriptAnimation(track, firstSetWidth, startX);
                            } else {
                                startAnimation(track);
                            }
                        }
                    }
                });
                requestImmediateRefresh();
            } else {
                if (pollTimer) {
                    clearTimeout(pollTimer);
                    pollTimer = null;
                }
            }
        });
        
        // 定期的にアニメーションの状態をチェックして、停止している場合は再開（20分以上継続させるため）
        const animationCheckInterval = setInterval(function() {
            if (document.hidden) {
                return;
            }
            const tracks = document.querySelectorAll('.slide-track');
            tracks.forEach(track => {
                if (track.dataset.loopEnabled === '1' && track.classList.contains('animate')) {
                    const loop = animationLoops.get(track);
                    const computedStyle = window.getComputedStyle(track);
                    const currentTransform = computedStyle.transform;
                    const currentTime = performance.now();
                    
                    // アニメーションが停止している、またはtransformが設定されていない場合は再開
                    let shouldRestart = false;
                    if (!loop || !loop.isRunning) {
                        shouldRestart = true;
                        console.log('[DEBUG] Animation loop not running', { trackId: track.id, hasLoop: !!loop, isRunning: loop?.isRunning });
                    } else if (!currentTransform || currentTransform === 'none') {
                        shouldRestart = true;
                        console.log('[DEBUG] Transform is none', { trackId: track.id });
                    } else if (loop.lastFrameTime && (currentTime - loop.lastFrameTime > 3000)) {
                    // 1秒以上フレームが更新されていない場合は再開（より頻繁にチェック）
                    shouldRestart = true;
                    console.log('[DEBUG] Frame not updating for 1+ seconds', { trackId: track.id, timeSinceLastFrame: currentTime - loop.lastFrameTime });
                    }
                    
                    if (shouldRestart) {
                        const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
                        if (firstSetWidth > 0) {
                            // 現在の位置を取得
                            let startX = 0;
                            if (currentTransform && currentTransform !== 'none') {
                                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                                if (matrix) {
                                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                                    startX = values[4] || 0;
                                }
                            }
                            console.log('[DEBUG] Restarting stopped animation', { trackId: track.id, startX, firstSetWidth });
                            startJavaScriptAnimation(track, firstSetWidth, startX);
                        }
                    }
                }
            });
        }, 250); // 0.25秒ごとにチェック（より頻繁にチェックして確実に継続）

        function insertTopLaneSkeleton() {
            const container = document.querySelector('.slideshow-app');
            const mainSection = document.querySelector('.slideshow-main');
            const topRowFragment = document.createElement('div');
            topRowFragment.className = 'slider-row top-row';

            const trackDiv = document.createElement('div');
            trackDiv.className = 'slide-track';
            trackDiv.id = 'topTrack';
            trackDiv.dataset.firstSetLength = '0';
            trackDiv.dataset.loopEnabled = '0';
            topRowFragment.appendChild(trackDiv);

            container.insertBefore(topRowFragment, mainSection);

            document.body.classList.remove('single-lane');

            topTrack = trackDiv;
        }
    </script>
</body>
</html>