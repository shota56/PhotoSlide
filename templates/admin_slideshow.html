<!DOCTYPE html>
<html>
<head>
    <title>管理者用ウェディングスライドショー</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow-x: hidden;
        }

        .slider-row {
            width: 100%;
            overflow: hidden;
            position: relative;
            white-space: nowrap;
        }

        .top-row {
            height: 35vh;
            background: rgba(0, 0, 0, 0.85);
        }

        .middle-row {
            height: 65vh;
            background: rgba(0, 0, 0, 0.92);
        }

        body.single-lane .top-row {
            display: none;
        }

        body.single-lane .middle-row {
            height: 80vh;
            margin-top: 10vh;
            background: rgba(0, 0, 0, 0.9);
        }

        body.single-lane .middle-row img {
            height: calc(80vh - 20px);
        }

        .slide-track {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
        }
        
        .slide-track.animate {
            animation: scroll 40s linear infinite;
        }

        .slide-track img {
            display: inline-block;
            margin: 10px;
        }

        .top-row img {
            height: calc(35vh - 20px);
            width: auto;
        }

        .middle-row img {
            height: calc(65vh - 20px);
            width: auto;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* アニメーションを無効化するクラス（初期状態） */
        .slide-track.init {
            animation: none;
        }
    </style>
</head>
<body class="theme-dark{% if not photos_top %} single-lane{% endif %}">
    {% if photos_top %}
    <div class="slider-row top-row">
        <div class="slide-track" id="topTrack" data-first-set-length="{{ photos_top|length }}">
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>
    {% endif %}

    <!-- 下段のスライダー -->
    <div class="slider-row middle-row">
        <div class="slide-track" id="middleTrack" data-first-set-length="{{ photos_recent|length }}">
            {% for photo in photos_recent %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_recent %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>

    <script type="application/json" id="slideshow-data">
        {{ {
            'photos': photos,
            'photoUrls': photo_urls,
            'topPhotos': photos_top,
            'topPhotoUrls': top_photo_urls,
            'recentPhotos': photos_recent,
            'recentPhotoUrls': recent_photo_urls
        } | tojson }}
    </script>

    <script>
        const FIXED_ANIMATION_DURATION = 120;
        const configElement = document.getElementById('slideshow-data');
        const uploadsBaseUrl = "{{ url_for('serve_upload', filename='__PLACEHOLDER__') }}".replace('__PLACEHOLDER__', '');
        const MIN_POLL_INTERVAL = 4000;
        const MAX_POLL_INTERVAL = 30000;
        const POLL_GROWTH_FACTOR = 1.6;
        let currentPhotos = [];
        let currentPhotoUrls = [];
        let topPhotos = [];
        let topPhotoUrls = [];
        let recentPhotos = [];
        let recentPhotoUrls = [];
         try {
             const parsed = JSON.parse(configElement.textContent);
             currentPhotos = Array.isArray(parsed.photos) ? parsed.photos.slice() : [];
             currentPhotoUrls = Array.isArray(parsed.photoUrls) ? parsed.photoUrls.slice() : [];
             topPhotos = Array.isArray(parsed.topPhotos) ? parsed.topPhotos.slice() : [];
             topPhotoUrls = Array.isArray(parsed.topPhotoUrls) ? parsed.topPhotoUrls.slice() : [];
             recentPhotos = Array.isArray(parsed.recentPhotos) ? parsed.recentPhotos.slice() : [];
             recentPhotoUrls = Array.isArray(parsed.recentPhotoUrls) ? parsed.recentPhotoUrls.slice() : [];
         } catch (e) {
             console.warn('Failed to parse slideshow config:', e);
             currentPhotos = [];
             currentPhotoUrls = [];
             topPhotos = [];
             topPhotoUrls = [];
             recentPhotos = [];
             recentPhotoUrls = [];
         }

         let lastPhotoCount = currentPhotos.length;
         let refreshTimer = null;
         let fetchInProgress = false;
         let lastStorageTimestamp = Date.now();
         let topTrack = document.getElementById('topTrack');
         const middleTrack = document.getElementById('middleTrack');
        let pollTimer = null;
        let currentPollInterval = MIN_POLL_INTERVAL;

        function scheduleNextPoll(delay = currentPollInterval) {
            if (pollTimer) {
                clearTimeout(pollTimer);
            }
            pollTimer = setTimeout(() => fetchLatestPhotos(), Math.max(0, delay));
        }

        function resetPollIntervalToMinimum() {
            currentPollInterval = MIN_POLL_INTERVAL;
        }

        function backoffPollInterval() {
            currentPollInterval = Math.min(MAX_POLL_INTERVAL, Math.round(currentPollInterval * POLL_GROWTH_FACTOR));
        }

        function requestImmediateRefresh() {
            resetPollIntervalToMinimum();
            scheduleNextPoll(0);
        }

        function scheduleRefresh() {
            if (refreshTimer) {
                return;
            }
            refreshTimer = setTimeout(() => {
                refreshTimer = null;
                requestImmediateRefresh();
            }, 600);
        }

        try {
            const channel = new BroadcastChannel('photo_upload');
            channel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'photo_uploaded') {
                    scheduleRefresh();
                }
            });
        } catch (e) {
            console.log('BroadcastChannel not supported in this browser.');
        }

        setInterval(() => {
            try {
                const stored = localStorage.getItem('last_uploaded_photo');
                if (!stored) {
                    return;
                }
                const data = JSON.parse(stored);
                if (!data || !data.filename || !data.timestamp) {
                    return;
                }
                if (data.timestamp > lastStorageTimestamp && !currentPhotos.includes(data.filename)) {
                    lastStorageTimestamp = data.timestamp;
                    requestImmediateRefresh();
                }
            } catch (error) {
            }
        }, 2000);

        function fetchLatestPhotos() {
            if (fetchInProgress) {
                return;
            }
            fetchInProgress = true;
            fetch('/api/photos')
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Network error');
                    }
                    return response.json();
                })
                .then((data) => {
                    if (!data || !Array.isArray(data.photos)) {
                        return;
                    }
                    const hasUpdates = handlePhotoListUpdate(data);
                    if (hasUpdates) {
                        resetPollIntervalToMinimum();
                    } else {
                        backoffPollInterval();
                    }
                })
                .catch(() => {
                    backoffPollInterval();
                })
                .finally(() => {
                    fetchInProgress = false;
                    scheduleNextPoll();
                });
        }

        function buildPhotoUrl(filename) {
            if (!filename) {
                return '';
            }
            return `${uploadsBaseUrl}${encodeURIComponent(filename)}`;
        }

        function arraysEqual(a, b) {
            if (!Array.isArray(a) || !Array.isArray(b)) {
                return false;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i += 1) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }

        function renderRecentTrack() {
            if (!middleTrack) {
                return;
            }
            middleTrack.innerHTML = '';
            const firstSetLength = recentPhotos.length;
            const shouldLoop = firstSetLength >= 10;
            middleTrack.dataset.firstSetLength = firstSetLength;
            const enableLoop = firstSetLength > 0;
            middleTrack.dataset.loopEnabled = enableLoop ? '1' : '0';

            if (!firstSetLength) {
                middleTrack.classList.remove('animate');
                middleTrack.style.animation = 'none';
                return;
            }

            const fragment = document.createDocumentFragment();
            recentPhotos.forEach((photo, index) => {
                const url = recentPhotoUrls[index] || buildPhotoUrl(photo);
                fragment.appendChild(createImageElement(url, photo));
            });
            middleTrack.appendChild(fragment);

            const duplicateFragment = document.createDocumentFragment();
            recentPhotos.forEach((photo, index) => {
                const url = recentPhotoUrls[index] || buildPhotoUrl(photo);
                duplicateFragment.appendChild(createImageElement(url, photo));
            });
            middleTrack.appendChild(duplicateFragment);
            restartTrackAnimation(middleTrack);

        }

        function renderTopTrack() {
            if (!topTrack) {
                return;
            }
            topTrack.innerHTML = '';
            const firstSetLength = topPhotos.length;
            const enableLoop = firstSetLength > 0;
            topTrack.dataset.firstSetLength = firstSetLength;
            topTrack.dataset.loopEnabled = enableLoop ? '1' : '0';

            if (!firstSetLength) {
                topTrack.classList.remove('animate');
                topTrack.style.animation = 'none';
                return;
            }

            const fragment = document.createDocumentFragment();
            topPhotos.forEach((photo, index) => {
                const url = topPhotoUrls[index] || buildPhotoUrl(photo);
                fragment.appendChild(createImageElement(url, photo));
            });
            topTrack.appendChild(fragment);

            const duplicateFragment = document.createDocumentFragment();
            topPhotos.forEach((photo, index) => {
                const url = topPhotoUrls[index] || buildPhotoUrl(photo);
                duplicateFragment.appendChild(createImageElement(url, photo));
            });
            topTrack.appendChild(duplicateFragment);
            restartTrackAnimation(topTrack);

        }

        function tryIncrementalShift(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                return false;
            }
            if (prevPhotos.length !== nextPhotos.length) {
                return false;
            }

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                return false;
            }

            for (let i = 0; i < nextPhotos.length - 1; i += 1) {
                if (nextPhotos[i] !== prevPhotos[i + 1]) {
                    return false;
                }
            }

            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            const expectedChildCount = firstSetLength * 2;
            if (track.children.length !== expectedChildCount) {
                return false;
            }

            const primaryToRemove = track.children[0];
            if (!primaryToRemove) {
                return false;
            }
            track.removeChild(primaryToRemove);

            const duplicateIndex = firstSetLength - 1;
            const duplicateToRemove = track.children[duplicateIndex];
            if (!duplicateToRemove) {
                return false;
            }
            track.removeChild(duplicateToRemove);

            const newPrimary = createImageElement(newUrl, newPhoto);
            const insertBeforeNode = track.children[duplicateIndex] || null;
            track.insertBefore(newPrimary, insertBeforeNode);

            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            track.dataset.firstSetLength = nextPhotos.length;
            return true;
        }

        function handlePhotoListUpdate(payload) {
            const newPhotos = Array.isArray(payload.photos) ? payload.photos : [];
            const newPhotoUrls = Array.isArray(payload.photo_urls) ? payload.photo_urls : null;
            if (!Array.isArray(newPhotos)) {
                return false;
            }
            if (newPhotos.length < currentPhotos.length) {
                return true;
            }

            const hadAddition = newPhotos.length > currentPhotos.length;

            const prevRecentPhotos = recentPhotos.slice();
            const prevRecentPhotoUrls = recentPhotoUrls.slice();
            const prevTopPhotos = topPhotos.slice();
            const prevTopPhotoUrls = topPhotoUrls.slice();

            currentPhotos = newPhotos.slice();
            if (Array.isArray(newPhotoUrls)) {
                currentPhotoUrls = newPhotoUrls.slice();
            } else if (hadAddition) {
                currentPhotoUrls = currentPhotos.map(buildPhotoUrl);
            }

            const payloadRecentPhotos = Array.isArray(payload.recent_photos) ? payload.recent_photos : null;
            const payloadRecentPhotoUrls = Array.isArray(payload.recent_photo_urls) ? payload.recent_photo_urls : null;
            const newRecentPhotos = payloadRecentPhotos ? payloadRecentPhotos.slice() : currentPhotos.slice(-10);
            const newRecentPhotoUrls = payloadRecentPhotoUrls
                ? payloadRecentPhotoUrls.slice()
                : (Array.isArray(newPhotoUrls)
                    ? newPhotoUrls.slice(-10)
                    : newRecentPhotos.map(buildPhotoUrl));

            const recentChanged = !arraysEqual(newRecentPhotos, recentPhotos) || !arraysEqual(newRecentPhotoUrls, recentPhotoUrls);

            if (recentChanged) {
                const handled = tryIncrementalShift(
                    middleTrack,
                    prevRecentPhotos,
                    prevRecentPhotoUrls,
                    newRecentPhotos,
                    newRecentPhotoUrls
                );
                recentPhotos = newRecentPhotos;
                recentPhotoUrls = newRecentPhotoUrls;
                if (!handled) {
                    renderRecentTrack();
                }
            }

            const payloadTopPhotos = Array.isArray(payload.top_photos) ? payload.top_photos : null;
            const payloadTopPhotoUrls = Array.isArray(payload.top_photo_urls) ? payload.top_photo_urls : null;
            const topStart = Math.max(0, currentPhotos.length - 30);
            const topEnd = Math.max(0, currentPhotos.length - 10);
            const newTopPhotos = payloadTopPhotos ? payloadTopPhotos.slice() : currentPhotos.slice(topStart, topEnd);
            const newTopPhotoUrls = payloadTopPhotoUrls
                ? payloadTopPhotoUrls.slice()
                : (Array.isArray(newPhotoUrls)
                    ? newPhotoUrls.slice(topStart, topEnd)
                    : newTopPhotos.map(buildPhotoUrl));

            const topChanged = !arraysEqual(newTopPhotos, topPhotos) || !arraysEqual(newTopPhotoUrls, topPhotoUrls);

            if (topChanged) {
                const handled = tryIncrementalShift(
                    topTrack,
                    prevTopPhotos,
                    prevTopPhotoUrls,
                    newTopPhotos,
                    newTopPhotoUrls
                );
                topPhotos = newTopPhotos;
                topPhotoUrls = newTopPhotoUrls;
                if (!handled) {
                    if (!topTrack && newTopPhotos.length) {
                        insertTopLaneSkeleton();
                    }
                    renderTopTrack();
                }
            }

            lastPhotoCount = currentPhotos.length;
            return hadAddition;
        }

        function createImageElement(url, filename) {
            const img = document.createElement('img');
            img.src = url || buildPhotoUrl(filename);
            img.alt = 'Photo';
            return img;
        }

        function initializeSlideshow() {
            const tracks = document.querySelectorAll('.slide-track');
            
            tracks.forEach((track) => {
                track.classList.add('init');
                
                const images = track.querySelectorAll('img');
                
                if (images.length === 0) {
                    return;
                }
                
                let loadedCount = 0;
                const totalImages = images.length;
                
                function checkAllLoaded() {
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        startAnimation(track);
                    }
                }
                
                images.forEach(img => {
                    if (img.complete) {
                        checkAllLoaded();
                    } else {
                        img.addEventListener('load', checkAllLoaded);
                        img.addEventListener('error', checkAllLoaded);
                    }
                });
                
                setTimeout(() => {
                    if (track.classList.contains('init')) {
                        startAnimation(track);
                    }
                }, 5000);
            });
        }
        
        function startAnimation(track) {
            if (track.dataset.loopEnabled !== '1') {
                track.classList.remove('animate');
                track.style.animation = 'none';
                return;
            }
            track.classList.remove('init');
            track.style.animation = `scroll ${FIXED_ANIMATION_DURATION}s linear infinite`;
            track.classList.add('animate');
        }

        function restartTrackAnimation(track) {
            if (!track) {
                return;
            }
            if (track.dataset.loopEnabled !== '1') {
                track.classList.remove('animate');
                track.style.animation = 'none';
                return;
            }
            track.classList.remove('animate');
            track.classList.add('init');
            track.style.animation = 'none';
            void track.offsetWidth;
            startAnimation(track);
        }
        
        window.addEventListener('load', function() {
            if (!topTrack && topPhotos.length) {
                insertTopLaneSkeleton();
            }
            renderTopTrack();
            renderRecentTrack();
            setTimeout(initializeSlideshow, 100);
            scheduleNextPoll();
        });
        
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                const tracks = document.querySelectorAll('.slide-track');
                tracks.forEach(track => {
                    if (!track.classList.contains('animate') && track.querySelectorAll('img').length > 0) {
                        startAnimation(track);
                    }
                });
                requestImmediateRefresh();
            } else {
                if (pollTimer) {
                    clearTimeout(pollTimer);
                    pollTimer = null;
                }
            }
        });

        function insertTopLaneSkeleton() {
            const container = document.querySelector('.slideshow-app');
            const mainSection = document.querySelector('.slideshow-main');
            const topRowFragment = document.createElement('div');
            topRowFragment.className = 'slider-row top-row';

            const trackDiv = document.createElement('div');
            trackDiv.className = 'slide-track';
            trackDiv.id = 'topTrack';
            trackDiv.dataset.firstSetLength = '0';
            trackDiv.dataset.loopEnabled = '0';
            topRowFragment.appendChild(trackDiv);

            container.insertBefore(topRowFragment, mainSection);

            document.body.classList.remove('single-lane');

            topTrack = trackDiv;
        }
    </script>
</body>
</html>