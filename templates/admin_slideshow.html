<!DOCTYPE html>
<html>
<head>
    <title>管理者用ウェディングスライドショー</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow-x: hidden;
        }

        .slider-row {
            width: 100%;
            overflow: hidden;
            position: relative;
            white-space: nowrap;
        }

        .top-row {
            height: 42vh;
            background: rgba(0, 0, 0, 0.85);
            margin-bottom: 8px;
        }

        .middle-row {
            height: 58vh;
            background: rgba(0, 0, 0, 0.92);
        }

        body.single-lane .top-row {
            display: none;
        }

        body.single-lane .middle-row {
            height: 90vh;
            margin-top: 5vh;
            background: rgba(0, 0, 0, 0.9);
        }

        body.single-lane .middle-row img {
            height: calc(90vh - 20px);
        }

        .slide-track {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
        }
        
        .slide-track.animate {
            /* アニメーションはJavaScriptで制御 */
        }

        .slide-track img {
            display: inline-block;
            margin: 8px;
            border-radius: 18px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        .top-row img {
            height: calc(38vh - 16px);
            width: auto;
        }

        .middle-row img {
            height: calc(54vh - 16px);
            width: auto;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* アニメーションを無効化するクラス（初期状態） */
        .slide-track.init {
            animation: none;
        }
    </style>
</head>
<body class="theme-dark{% if not photos_top %} single-lane{% endif %}">
    {% if photos_top %}
    <div class="slider-row top-row">
        <div class="slide-track" id="topTrack" data-first-set-length="{{ photos_top|length }}">
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_top %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>
    {% endif %}

    <!-- 下段のスライダー -->
    <div class="slider-row middle-row">
        <div class="slide-track" id="middleTrack" data-first-set-length="{{ photos_recent|length }}">
            {% for photo in photos_recent %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
            {% for photo in photos_recent %}
                <img src="{{ url_for('serve_upload', filename=photo) }}" alt="Photo">
            {% endfor %}
        </div>
    </div>

    <script type="application/json" id="slideshow-data">
        {{ {
            'photos': photos,
            'photoUrls': photo_urls,
            'topPhotos': photos_top,
            'topPhotoUrls': top_photo_urls,
            'recentPhotos': photos_recent,
            'recentPhotoUrls': recent_photo_urls
        } | tojson }}
    </script>

    <script>
        const FIXED_ANIMATION_DURATION = 120;
        const configElement = document.getElementById('slideshow-data');
        const uploadsBaseUrl = "{{ url_for('serve_upload', filename='__PLACEHOLDER__') }}".replace('__PLACEHOLDER__', '');
        const MIN_POLL_INTERVAL = 4000;
        const MAX_POLL_INTERVAL = 30000;
        const POLL_GROWTH_FACTOR = 1.6;
        let currentPhotos = [];
        let currentPhotoUrls = [];
        let topPhotos = [];
        let topPhotoUrls = [];
        let recentPhotos = [];
        let recentPhotoUrls = [];
        
        // アニメーション制御用の変数
        const animationLoops = new Map(); // track -> { startX, targetX, startTime, firstSetWidth, isRunning }
         try {
             const parsed = JSON.parse(configElement.textContent);
             currentPhotos = Array.isArray(parsed.photos) ? parsed.photos.slice() : [];
             currentPhotoUrls = Array.isArray(parsed.photoUrls) ? parsed.photoUrls.slice() : [];
             topPhotos = Array.isArray(parsed.topPhotos) ? parsed.topPhotos.slice() : [];
             topPhotoUrls = Array.isArray(parsed.topPhotoUrls) ? parsed.topPhotoUrls.slice() : [];
             recentPhotos = Array.isArray(parsed.recentPhotos) ? parsed.recentPhotos.slice() : [];
             recentPhotoUrls = Array.isArray(parsed.recentPhotoUrls) ? parsed.recentPhotoUrls.slice() : [];
        } catch (e) {
             console.warn('Failed to parse slideshow config:', e);
            currentPhotos = [];
             currentPhotoUrls = [];
             topPhotos = [];
             topPhotoUrls = [];
             recentPhotos = [];
             recentPhotoUrls = [];
        }

        let lastPhotoCount = currentPhotos.length;
        let refreshTimer = null;
         let fetchInProgress = false;
        let lastStorageTimestamp = Date.now();
         let topTrack = document.getElementById('topTrack');
         const middleTrack = document.getElementById('middleTrack');
        let pollTimer = null;
        let currentPollInterval = MIN_POLL_INTERVAL;

        function scheduleNextPoll(delay = currentPollInterval) {
            if (pollTimer) {
                clearTimeout(pollTimer);
            }
            pollTimer = setTimeout(() => fetchLatestPhotos(), Math.max(0, delay));
        }

        function resetPollIntervalToMinimum() {
            currentPollInterval = MIN_POLL_INTERVAL;
        }

        function backoffPollInterval() {
            currentPollInterval = Math.min(MAX_POLL_INTERVAL, Math.round(currentPollInterval * POLL_GROWTH_FACTOR));
        }

        function requestImmediateRefresh(silent = false) {
            resetPollIntervalToMinimum();
            fetchLatestPhotos(silent);
        }

        function scheduleRefresh() {
            if (refreshTimer) {
                return;
            }
            refreshTimer = setTimeout(() => {
                refreshTimer = null;
                requestImmediateRefresh();
            }, 600);
        }

        try {
            const channel = new BroadcastChannel('photo_upload');
            channel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'photo_uploaded') {
                    scheduleRefresh();
                }
            });
        } catch (e) {
            console.log('BroadcastChannel not supported in this browser.');
        }

        setInterval(() => {
            try {
                const stored = localStorage.getItem('last_uploaded_photo');
                if (!stored) {
                    return;
                }
                const data = JSON.parse(stored);
                if (!data || !data.filename || !data.timestamp) {
                    return;
                }
                if (data.timestamp > lastStorageTimestamp && !currentPhotos.includes(data.filename)) {
                    lastStorageTimestamp = data.timestamp;
                    requestImmediateRefresh();
                }
            } catch (error) {
            }
        }, 2000);

        function fetchLatestPhotos(silent = false) {
            if (fetchInProgress) {
                return;
            }
            fetchInProgress = true;
            fetch('/api/photos')
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Network error');
                    }
                    return response.json();
                })
                .then((data) => {
                    if (!data || !Array.isArray(data.photos)) {
                        return;
                    }
                    const hasUpdates = handlePhotoListUpdate(data);
                    if (hasUpdates) {
                        resetPollIntervalToMinimum();
                    } else {
                        backoffPollInterval();
                    }
                })
                .catch(() => {
                    backoffPollInterval();
                })
                .finally(() => {
                    fetchInProgress = false;
                    if (!silent) {
                        scheduleNextPoll();
                    }
                });
        }

        function buildPhotoUrl(filename) {
            if (!filename) {
                return '';
            }
            return `${uploadsBaseUrl}${encodeURIComponent(filename)}`;
        }

        function arraysEqual(a, b) {
            if (!Array.isArray(a) || !Array.isArray(b)) {
                return false;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i += 1) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }

        function renderRecentTrack(preservePosition = false) {
            if (!middleTrack) {
                return;
            }
            
            // 位置を保持する場合、現在の位置を取得（DOMをクリアする前に）
            let currentTranslateX = 0;
            let oldFirstSetWidth = 0;
            if (preservePosition) {
                // まず、実際のtransform値から現在の位置を取得（最も正確）
                const computedStyle = window.getComputedStyle(middleTrack);
                const currentTransform = computedStyle.transform;
                if (currentTransform && currentTransform !== 'none') {
                    const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                    if (matrix) {
                        const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                        currentTranslateX = values[4] || 0;
                    }
                }
                oldFirstSetWidth = middleTrack.dataset.firstSetWidth ? parseFloat(middleTrack.dataset.firstSetWidth) : 0;
                
                // アニメーションループを停止
                const loop = animationLoops.get(middleTrack);
                if (loop && loop.isRunning) {
                    loop.isRunning = false;
                }
                
                console.log('[DEBUG renderRecentTrack] Preserving position from transform:', currentTranslateX, 'oldFirstSetWidth:', oldFirstSetWidth);
                
                // 位置が取得できなかった場合は、位置を保持しない
                if (currentTranslateX === 0 && oldFirstSetWidth === 0) {
                    console.log('[DEBUG renderRecentTrack] Could not get position, not preserving');
                    preservePosition = false;
                }
            } else {
                console.log('[DEBUG renderRecentTrack] Not preserving position (preservePosition = false)');
            }
            
            middleTrack.innerHTML = '';
            const firstSetLength = recentPhotos.length;
            const shouldLoop = firstSetLength >= 10;
            middleTrack.dataset.firstSetLength = firstSetLength;
            const enableLoop = firstSetLength > 0;
            middleTrack.dataset.loopEnabled = enableLoop ? '1' : '0';

            if (!firstSetLength) {
                middleTrack.classList.remove('animate');
                middleTrack.style.animation = 'none';
                return;
            }

            const fragment = document.createDocumentFragment();
            recentPhotos.forEach((photo, index) => {
                const url = recentPhotoUrls[index] || buildPhotoUrl(photo);
                fragment.appendChild(createImageElement(url, photo));
            });
            middleTrack.appendChild(fragment);

            const duplicateFragment = document.createDocumentFragment();
            recentPhotos.forEach((photo, index) => {
                const url = recentPhotoUrls[index] || buildPhotoUrl(photo);
                duplicateFragment.appendChild(createImageElement(url, photo));
            });
            middleTrack.appendChild(duplicateFragment);
            
            // 画像の読み込みを待つ
            const imageLoadPromises = Array.from(middleTrack.querySelectorAll('img')).map(img => {
                if (img.complete) {
                    return Promise.resolve();
                }
                return new Promise((resolve) => {
                    img.addEventListener('load', resolve, { once: true });
                    img.addEventListener('error', resolve, { once: true });
                    setTimeout(resolve, 2000);
                });
            });

            Promise.all(imageLoadPromises).then(() => {
                requestAnimationFrame(() => {
                    if (middleTrack.children.length > 0) {
                        const firstImageWidth = middleTrack.children[0].getBoundingClientRect().width;
                        if (firstImageWidth === 0) {
                            console.log('[DEBUG renderRecentTrack] Image width is 0, retrying...');
                            setTimeout(() => {
                                const retryWidth = middleTrack.children[0].getBoundingClientRect().width;
                                if (retryWidth > 0) {
                                    const firstSetWidth = retryWidth * firstSetLength;
                                    middleTrack.dataset.firstSetWidth = firstSetWidth.toString();
                                    handleAnimationStart(middleTrack, firstSetWidth, preservePosition, oldFirstSetWidth, currentTranslateX);
                                } else {
                                    restartTrackAnimation(middleTrack);
                                }
                            }, 100);
                            return;
                        }
                        
                        const firstSetWidth = firstImageWidth * firstSetLength;
                        middleTrack.dataset.firstSetWidth = firstSetWidth.toString();
                        handleAnimationStart(middleTrack, firstSetWidth, preservePosition, oldFirstSetWidth, currentTranslateX);
                    } else {
                        restartTrackAnimation(middleTrack);
                    }
                });
            });
        }
        
        function startJavaScriptAnimation(track, firstSetWidth, startX = 0) {
            if (!track || firstSetWidth <= 0) {
                console.log('[DEBUG startJavaScriptAnimation] Invalid parameters', { track: !!track, firstSetWidth });
                return;
            }
            
            // 既存のアニメーションループを停止
            const existingLoop = animationLoops.get(track);
            if (existingLoop && existingLoop.isRunning) {
                existingLoop.isRunning = false;
                console.log('[DEBUG startJavaScriptAnimation] Stopped existing loop');
            }
            
            // 新しいアニメーションループを開始
            const loop = {
                startX: startX,
                targetX: startX - firstSetWidth,
                startTime: performance.now(),
                firstSetWidth: firstSetWidth,
                isRunning: true
            };
            animationLoops.set(track, loop);
            
            console.log('[DEBUG startJavaScriptAnimation] Starting animation', {
                startX,
                targetX: loop.targetX,
                firstSetWidth,
                trackId: track.id
            });
            
            function animateFrame() {
                const loop = animationLoops.get(track);
                if (!loop || !loop.isRunning || !track.classList.contains('animate')) {
                    if (!loop || !loop.isRunning) {
                        console.log('[DEBUG animateFrame] Loop stopped', { hasLoop: !!loop, isRunning: loop?.isRunning });
                    }
                    return;
                }
                
                const elapsed = (performance.now() - loop.startTime) / 1000;
                const progress = elapsed / FIXED_ANIMATION_DURATION;
                
                if (progress < 1) {
                    // 1サイクル未満の場合
                    const currentX = loop.startX + (loop.targetX - loop.startX) * progress;
                    track.style.transform = `translateX(${currentX}px)`;
                    requestAnimationFrame(animateFrame);
                } else {
                    // 1サイクル完了したら、ループを継続
                    const cycleCount = Math.floor(progress);
                    const remainingProgress = progress - cycleCount;
                    const currentX = loop.startX - (loop.firstSetWidth * cycleCount) - (loop.firstSetWidth * remainingProgress);
                    track.style.transform = `translateX(${currentX}px)`;
                    
                    // 次のサイクルを開始
                    loop.startX = currentX;
                    loop.targetX = currentX - loop.firstSetWidth;
                    loop.startTime = performance.now();
                    requestAnimationFrame(animateFrame);
                }
            }
            
            track.classList.add('animate');
            track.style.animation = 'none';
            // 開始位置を設定（重要：これがないと位置がリセットされる）
            track.style.transform = `translateX(${startX}px)`;
            console.log('[DEBUG startJavaScriptAnimation] Set initial transform:', startX);
            requestAnimationFrame(animateFrame);
        }
        
        function handleAnimationStart(track, firstSetWidth, preservePosition, oldFirstSetWidth, currentTranslateX) {
            if (preservePosition && oldFirstSetWidth > 0 && currentTranslateX !== 0 && firstSetWidth > 0) {
                // 位置を保持する場合、現在の位置を調整
                // 直接比率で調整（より正確で、ズレが少ない）
                const adjustedTranslateX = (currentTranslateX * firstSetWidth) / oldFirstSetWidth;
                console.log('[DEBUG handleAnimationStart] Preserving position:', adjustedTranslateX, 'from', currentTranslateX, 'oldWidth:', oldFirstSetWidth, 'newWidth:', firstSetWidth);
                // 位置が0に近い場合は、位置を保持しない（初期化時など）
                if (Math.abs(adjustedTranslateX) < 10) {
                    console.log('[DEBUG handleAnimationStart] Position too close to 0, starting from 0');
                    startJavaScriptAnimation(track, firstSetWidth, 0);
                } else {
                    startJavaScriptAnimation(track, firstSetWidth, adjustedTranslateX);
                }
            } else {
                // 位置を保持しない場合、最初から開始
                startJavaScriptAnimation(track, firstSetWidth, 0);
            }
        }

        function renderTopTrack() {
            if (!topPhotos.length) {
                if (topTrack) {
                    topTrack.parentElement.remove();
                    topTrack = null;
                    document.body.classList.add('single-lane');
                }
                return;
            }

            if (!topTrack) {
                insertTopLaneSkeleton();
                topTrack = document.getElementById('topTrack');
                // renderRecentTrackは呼ばない（位置をリセットしない）
            }

            if (!topTrack) {
                return;
            }

            document.body.classList.remove('single-lane');

            topTrack.innerHTML = '';
            const firstSetLength = topPhotos.length;
            topTrack.dataset.firstSetLength = firstSetLength;
            topTrack.dataset.loopEnabled = '1';

            const fragment = document.createDocumentFragment();
            topPhotos.forEach((photo, index) => {
                const url = topPhotoUrls[index] || buildPhotoUrl(photo);
                fragment.appendChild(createImageElement(url, photo));
            });
            topTrack.appendChild(fragment);

            const duplicateFragment = document.createDocumentFragment();
            topPhotos.forEach((photo, index) => {
                const url = topPhotoUrls[index] || buildPhotoUrl(photo);
                duplicateFragment.appendChild(createImageElement(url, photo));
            });
            topTrack.appendChild(duplicateFragment);
            
            requestAnimationFrame(() => {
                if (topTrack && topTrack.children.length > 0) {
                    const firstImageWidth = topTrack.children[0].getBoundingClientRect().width;
                    const firstSetWidth = firstImageWidth * firstSetLength;
                    topTrack.dataset.firstSetWidth = firstSetWidth.toString();
                }
                restartTrackAnimation(topTrack);
                // renderRecentTrackは呼ばない（位置をリセットしない）
            });
        }

        function getCurrentAnimationProgress(track) {
            if (!track || !track.classList.contains('animate')) {
                return 0;
            }
            const computedStyle = window.getComputedStyle(track);
            const transform = computedStyle.transform;
            if (!transform || transform === 'none') {
                return 0;
            }
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (!matrix) {
                return 0;
            }
            const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
            const translateX = values[4] || 0;
            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth === 0) {
                return 0;
            }
            const progress = Math.abs(translateX) / firstSetWidth;
            return progress % 1;
        }

        function smoothAddNewPhoto(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            console.log('[DEBUG smoothAddNewPhoto] Start');
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: track or arrays invalid');
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                console.log('[DEBUG smoothAddNewPhoto] Failed: loop not enabled', track.dataset.loopEnabled);
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: empty arrays', prevPhotos.length, nextPhotos.length);
                return false;
            }
            if (nextPhotos.length !== prevPhotos.length + 1) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: length mismatch', prevPhotos.length, nextPhotos.length);
                return false;
            }
            for (let i = 0; i < prevPhotos.length; i += 1) {
                if (nextPhotos[i] !== prevPhotos[i]) {
                    console.log('[DEBUG smoothAddNewPhoto] Failed: photo order changed at index', i, prevPhotos[i], nextPhotos[i]);
                    return false;
                }
            }
            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                console.log('[DEBUG smoothAddNewPhoto] Failed: firstSetLength mismatch', firstSetLength, prevPhotos.length);
                return false;
            }

            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth === 0) {
                const firstImageWidth = track.children[0] ? track.children[0].getBoundingClientRect().width : 0;
                if (firstImageWidth === 0) {
                    console.log('[DEBUG smoothAddNewPhoto] Failed: cannot get image width');
                    return false;
                }
                const calculatedWidth = firstImageWidth * firstSetLength;
                track.dataset.firstSetWidth = calculatedWidth.toString();
                console.log('[DEBUG smoothAddNewPhoto] Calculated width, returning false to retry');
                return false;
            }
            
            console.log('[DEBUG smoothAddNewPhoto] All checks passed, proceeding with photo addition');

            // 現在のアニメーション進行状況を取得
            // アニメーションを一時停止してから位置を取得
            track.style.animationPlayState = 'paused';
            const computedStyle = window.getComputedStyle(track);
            const currentTransform = computedStyle.transform;
            let currentTranslateX = 0;
            
            if (currentTransform && currentTransform !== 'none') {
                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                if (matrix) {
                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                    currentTranslateX = values[4] || 0;
                }
            }
            
            // 現在の位置が取得できない場合は、進行状況から計算
            if (currentTranslateX === 0 && track.classList.contains('animate')) {
                const currentProgress = getCurrentAnimationProgress(track);
                currentTranslateX = -(currentProgress * firstSetWidth);
                console.log('[DEBUG smoothAddNewPhoto] Calculated position from progress:', currentProgress, currentTranslateX);
            }
            
            console.log('[DEBUG smoothAddNewPhoto] Current position:', currentTranslateX, 'firstSetWidth:', firstSetWidth);
            
            // アニメーションを完全に停止（クラスを削除）
            track.classList.remove('animate');
            track.style.animation = 'none';
            track.style.transform = `translateX(${currentTranslateX}px)`;
            void track.offsetWidth; // リフローを強制

            // 新しい写真を追加（最初のセットの最後に追加）
            const newPrimary = createImageElement(newUrl, newPhoto);
            const duplicateIndex = firstSetLength;
            const insertBeforeNode = track.children[duplicateIndex] || null;
            track.insertBefore(newPrimary, insertBeforeNode);

            // 2つ目のセットの最後にも追加
            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            track.dataset.firstSetLength = nextPhotos.length;

            // 画像の読み込みを待ってからアニメーションを再開
            const imageLoadPromises = [newPrimary, newDuplicate].map(img => {
                if (img.complete) {
                    return Promise.resolve();
                }
                return new Promise((resolve) => {
                    img.addEventListener('load', resolve, { once: true });
                    img.addEventListener('error', resolve, { once: true });
                    setTimeout(resolve, 1000);
                });
            });

            Promise.all(imageLoadPromises).then(() => {
                requestAnimationFrame(() => {
                    const firstImageWidth = track.children[0] ? track.children[0].getBoundingClientRect().width : 0;
                    if (firstImageWidth === 0) {
                        restartTrackAnimation(track, true);
                        return;
                    }
                    
                    const newFirstSetWidth = firstImageWidth * nextPhotos.length;
                    track.dataset.firstSetWidth = newFirstSetWidth.toString();
                    
                    // 現在の位置を新しい幅に合わせて調整
                    // currentTranslateXは既にピクセル値なので、新しい幅に対する比率を計算
                    const adjustedTranslateX = (currentTranslateX * newFirstSetWidth) / firstSetWidth;
                    
                    // 現在の位置を保持したまま、JavaScriptでアニメーションを制御
                    let animationStartTime = performance.now();
                    let animationStartX = adjustedTranslateX;
                    const targetX = adjustedTranslateX - newFirstSetWidth; // 1サイクル分進める
                    
                    // アニメーション関数
                    function animateFrame() {
                        if (!track.classList.contains('animate')) {
                            return;
                        }
                        const elapsed = (performance.now() - animationStartTime) / 1000;
                        const progress = Math.min(elapsed / FIXED_ANIMATION_DURATION, 1);
                        const currentX = animationStartX + (targetX - animationStartX) * progress;
                        track.style.transform = `translateX(${currentX}px)`;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateFrame);
                        } else {
                            // 1サイクル完了したら、現在の位置から通常のCSSアニメーションに切り替え
                            // ただし、位置を保持するために、アニメーションの開始位置を調整
                            const finalX = currentX % (-newFirstSetWidth);
                            track.style.transform = `translateX(${finalX}px)`;
                            track.style.animation = `scroll ${FIXED_ANIMATION_DURATION}s linear infinite`;
                            // 現在の位置から開始するために、animation-delayを使用
                            const remainingProgress = Math.abs(finalX) / newFirstSetWidth;
                            const delay = -remainingProgress * FIXED_ANIMATION_DURATION;
                            track.style.animationDelay = `${delay}s`;
                            // 1サイクル後にdelayをリセット
                            setTimeout(() => {
                                if (track.classList.contains('animate')) {
                                    track.style.animationDelay = '0s';
                                }
                            }, (1 - remainingProgress) * FIXED_ANIMATION_DURATION * 1000);
                        }
                    }
                    
                    // アニメーションを開始
                    track.classList.add('animate');
                    track.style.animation = 'none';
                    requestAnimationFrame(animateFrame);
                });
            });

            return true;
        }

        function smoothAddNewPhotoAtEnd(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            console.log('[DEBUG smoothAddNewPhotoAtEnd] Start');
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: track or arrays invalid');
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: loop not enabled', track.dataset.loopEnabled);
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: empty arrays', prevPhotos.length, nextPhotos.length);
                return false;
            }
            if (prevPhotos.length !== nextPhotos.length) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: length mismatch', prevPhotos.length, nextPhotos.length);
                return false;
            }

            // 最初のN-1個の要素が一致し、最後の要素が新しい写真であることを確認
            const prevPhotosMatch = prevPhotos.slice(0, -1).every((photo, i) => photo === nextPhotos[i]);
            const newPhotoAtEnd = nextPhotos[nextPhotos.length - 1] !== prevPhotos[prevPhotos.length - 1];
            
            console.log('[DEBUG smoothAddNewPhotoAtEnd] Checking conditions:', {
                prevPhotosMatch,
                newPhotoAtEnd,
                prevLast: prevPhotos[prevPhotos.length - 1],
                nextLast: nextPhotos[nextPhotos.length - 1],
                prevFirst: prevPhotos[0],
                nextFirst: nextPhotos[0],
                prevSlice: prevPhotos.slice(0, -1),
                nextSlice: nextPhotos.slice(0, -1)
            });
            
            if (!prevPhotosMatch || !newPhotoAtEnd) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: not a simple end addition', {
                    prevPhotosMatch,
                    newPhotoAtEnd,
                    prevLast: prevPhotos[prevPhotos.length - 1],
                    nextLast: nextPhotos[nextPhotos.length - 1]
                });
                return false;
            }

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: firstSetLength mismatch', firstSetLength, prevPhotos.length);
                return false;
            }

            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth === 0) {
                console.log('[DEBUG smoothAddNewPhotoAtEnd] Failed: firstSetWidth is 0');
                return false;
            }

            // 現在の位置を取得
            track.style.animationPlayState = 'paused';
            const computedStyle = window.getComputedStyle(track);
            const currentTransform = computedStyle.transform;
            let currentTranslateX = 0;
            
            if (currentTransform && currentTransform !== 'none') {
                const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                if (matrix) {
                    const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                    currentTranslateX = values[4] || 0;
                }
            }
            
            if (currentTranslateX === 0 && track.classList.contains('animate')) {
                const currentProgress = getCurrentAnimationProgress(track);
                currentTranslateX = -(currentProgress * firstSetWidth);
            }
            
            console.log('[DEBUG smoothAddNewPhotoAtEnd] Current position:', currentTranslateX, 'firstSetWidth:', firstSetWidth);

            // アニメーションを停止
            track.classList.remove('animate');
            track.style.animation = 'none';
            track.style.transform = `translateX(${currentTranslateX}px)`;
            void track.offsetWidth;

            // 最後の要素（古い最後の写真）を削除し、新しい写真を追加
            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            // 最初のセットの最後の要素を削除
            const lastPrimaryIndex = firstSetLength - 1;
            const lastPrimary = track.children[lastPrimaryIndex];
            if (lastPrimary) {
                track.removeChild(lastPrimary);
            }

            // 2つ目のセットの最後の要素を削除
            const lastDuplicateIndex = firstSetLength * 2 - 1;
            const lastDuplicate = track.children[lastDuplicateIndex];
            if (lastDuplicate) {
                track.removeChild(lastDuplicate);
            }

            // 新しい写真を最初のセットの最後に追加
            const newPrimary = createImageElement(newUrl, newPhoto);
            const insertBeforeNode = track.children[firstSetLength - 1] || null;
            if (insertBeforeNode) {
                track.insertBefore(newPrimary, insertBeforeNode.nextSibling);
            } else {
                track.appendChild(newPrimary);
            }

            // 新しい写真を2つ目のセットの最後に追加
            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            // 画像の読み込みを待つ
            const imageLoadPromises = [newPrimary, newDuplicate].map(img => {
                if (img.complete) {
                    return Promise.resolve();
                }
                return new Promise((resolve) => {
                    img.addEventListener('load', resolve, { once: true });
                    img.addEventListener('error', resolve, { once: true });
                    setTimeout(resolve, 1000);
                });
            });

            Promise.all(imageLoadPromises).then(() => {
                requestAnimationFrame(() => {
                    const firstImageWidth = track.children[0] ? track.children[0].getBoundingClientRect().width : 0;
                    if (firstImageWidth === 0) {
                        restartTrackAnimation(track, true);
                        return;
                    }
                    
                    const newFirstSetWidth = firstImageWidth * nextPhotos.length;
                    track.dataset.firstSetWidth = newFirstSetWidth.toString();
                    
                    // 現在の位置を新しい幅に合わせて調整
                    const adjustedTranslateX = (currentTranslateX * newFirstSetWidth) / firstSetWidth;
                    
                    // 現在の位置を保持したまま、JavaScriptでアニメーションを制御
                    let animationStartTime = performance.now();
                    let animationStartX = adjustedTranslateX;
                    const targetX = adjustedTranslateX - newFirstSetWidth;
                    
                    function animateFrame() {
                        if (!track.classList.contains('animate')) {
                            return;
                        }
                        const elapsed = (performance.now() - animationStartTime) / 1000;
                        const progress = Math.min(elapsed / FIXED_ANIMATION_DURATION, 1);
                        const currentX = animationStartX + (targetX - animationStartX) * progress;
                        track.style.transform = `translateX(${currentX}px)`;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateFrame);
                        } else {
                            // 1サイクル完了したら、現在の位置から通常のCSSアニメーションに切り替え
                            const finalX = currentX % (-newFirstSetWidth);
                            track.style.transform = `translateX(${finalX}px)`;
                            track.style.animation = `scroll ${FIXED_ANIMATION_DURATION}s linear infinite`;
                            const remainingProgress = Math.abs(finalX) / newFirstSetWidth;
                            const delay = -remainingProgress * FIXED_ANIMATION_DURATION;
                            track.style.animationDelay = `${delay}s`;
                            setTimeout(() => {
                                if (track.classList.contains('animate')) {
                                    track.style.animationDelay = '0s';
                                }
                            }, (1 - remainingProgress) * FIXED_ANIMATION_DURATION * 1000);
                        }
                    }
                    
                    track.classList.add('animate');
                    track.style.animation = 'none';
                    requestAnimationFrame(animateFrame);
                });
            });

            return true;
        }

        function tryIncrementalShift(track, prevPhotos, prevPhotoUrls, nextPhotos, nextPhotoUrls) {
            console.log('[DEBUG tryIncrementalShift] Start');
            if (!track || !Array.isArray(prevPhotos) || !Array.isArray(nextPhotos)) {
                console.log('[DEBUG tryIncrementalShift] Failed: track or arrays invalid');
                return false;
            }
            if (track.dataset.loopEnabled !== '1') {
                console.log('[DEBUG tryIncrementalShift] Failed: loop not enabled', track.dataset.loopEnabled);
                return false;
            }
            if (prevPhotos.length === 0 || nextPhotos.length === 0) {
                console.log('[DEBUG tryIncrementalShift] Failed: empty arrays', prevPhotos.length, nextPhotos.length);
                return false;
            }
            if (prevPhotos.length !== nextPhotos.length) {
                console.log('[DEBUG tryIncrementalShift] Failed: length mismatch', prevPhotos.length, nextPhotos.length);
                return false;
            }

            const firstSetLength = Number(track.dataset.firstSetLength || 0);
            if (firstSetLength !== prevPhotos.length) {
                console.log('[DEBUG tryIncrementalShift] Failed: firstSetLength mismatch', firstSetLength, prevPhotos.length);
                return false;
            }

            for (let i = 0; i < nextPhotos.length - 1; i += 1) {
                if (nextPhotos[i] !== prevPhotos[i + 1]) {
                    console.log('[DEBUG tryIncrementalShift] Failed: photo order mismatch at index', i, 'next:', nextPhotos[i], 'prev[i+1]:', prevPhotos[i + 1]);
                    return false;
                }
            }
            console.log('[DEBUG tryIncrementalShift] All checks passed, proceeding with shift');

            const newPhoto = nextPhotos[nextPhotos.length - 1];
            const newUrl = nextPhotoUrls
                ? nextPhotoUrls[nextPhotoUrls.length - 1]
                : buildPhotoUrl(newPhoto);

            const expectedChildCount = firstSetLength * 2;
            if (track.children.length !== expectedChildCount) {
                return false;
            }

            const primaryToRemove = track.children[0];
            if (!primaryToRemove) {
                return false;
            }
            track.removeChild(primaryToRemove);

            const duplicateIndex = firstSetLength - 1;
            const duplicateToRemove = track.children[duplicateIndex];
            if (!duplicateToRemove) {
                return false;
            }
            track.removeChild(duplicateToRemove);

            const newPrimary = createImageElement(newUrl, newPhoto);
            const insertBeforeNode = track.children[duplicateIndex] || null;
            track.insertBefore(newPrimary, insertBeforeNode);

            const newDuplicate = createImageElement(newUrl, newPhoto);
            track.appendChild(newDuplicate);

            track.dataset.firstSetLength = nextPhotos.length;
            return true;
        }

        function handlePhotoListUpdate(payload) {
            const newPhotos = Array.isArray(payload.photos) ? payload.photos : [];
            const newPhotoUrls = Array.isArray(payload.photo_urls) ? payload.photo_urls : null;
            if (!Array.isArray(newPhotos)) {
                return false;
            }
            if (newPhotos.length < currentPhotos.length) {
                return true;
            }

            const hadAddition = newPhotos.length > currentPhotos.length;

            const prevRecentPhotos = recentPhotos.slice();
            const prevRecentPhotoUrls = recentPhotoUrls.slice();
            const prevTopPhotos = topPhotos.slice();
            const prevTopPhotoUrls = topPhotoUrls.slice();

            currentPhotos = newPhotos.slice();
            if (Array.isArray(newPhotoUrls)) {
                currentPhotoUrls = newPhotoUrls.slice();
            } else if (hadAddition) {
                currentPhotoUrls = currentPhotos.map(buildPhotoUrl);
            }

            const payloadRecentPhotos = Array.isArray(payload.recent_photos) ? payload.recent_photos : null;
            const payloadRecentPhotoUrls = Array.isArray(payload.recent_photo_urls) ? payload.recent_photo_urls : null;
            // 最新10投稿が2レーン目
            const newRecentPhotos = payloadRecentPhotos ? payloadRecentPhotos.slice() : currentPhotos.slice(0, 10);
            const newRecentPhotoUrls = payloadRecentPhotoUrls
                ? payloadRecentPhotoUrls.slice()
                : (Array.isArray(newPhotoUrls)
                    ? newPhotoUrls.slice(0, 10)
                    : newRecentPhotos.map(buildPhotoUrl));

            const recentChanged = !arraysEqual(newRecentPhotos, recentPhotos) || !arraysEqual(newRecentPhotoUrls, recentPhotoUrls);
            
            // recentPhotosの内容が変わった場合、写真が追加された可能性がある
            // 配列の内容が変わっているか確認（最初の要素や最後の要素が変わっている場合）
            const arraysCompletelyEqual = arraysEqual(newRecentPhotos, prevRecentPhotos) && arraysEqual(newRecentPhotoUrls, prevRecentPhotoUrls);
            const firstElementChanged = newRecentPhotos.length > 0 && prevRecentPhotos.length > 0 && newRecentPhotos[0] !== prevRecentPhotos[0];
            const lastElementChanged = newRecentPhotos.length > 0 && prevRecentPhotos.length > 0 && newRecentPhotos[newRecentPhotos.length - 1] !== prevRecentPhotos[prevRecentPhotos.length - 1];
            const hasNewPhotoInRecent = recentChanged && !arraysCompletelyEqual && (
                hadAddition || 
                firstElementChanged ||
                lastElementChanged ||
                (newRecentPhotos.length > 0 && !prevRecentPhotos.includes(newRecentPhotos[newRecentPhotos.length - 1]))
            );

            if (recentChanged) {
                let handled = false;
                console.log('[DEBUG] recentChanged:', {
                    prevLength: prevRecentPhotos.length,
                    newLength: newRecentPhotos.length,
                    hadAddition: hadAddition,
                    hasNewPhotoInRecent: hasNewPhotoInRecent,
                    condition1: newRecentPhotos.length === prevRecentPhotos.length + 1 && hadAddition,
                    condition2: newRecentPhotos.length === prevRecentPhotos.length && hadAddition,
                    prevFirst: prevRecentPhotos[0],
                    newFirst: newRecentPhotos[0],
                    prevLast: prevRecentPhotos[prevRecentPhotos.length - 1],
                    newLast: newRecentPhotos[newRecentPhotos.length - 1]
                });
                
                // ケース1: 配列の長さが1つ増える場合（10枚→11枚）
                if (newRecentPhotos.length === prevRecentPhotos.length + 1 && hadAddition) {
                    console.log('[DEBUG] Calling smoothAddNewPhoto (case 1: length increased)');
                    handled = smoothAddNewPhoto(
                        middleTrack,
                        prevRecentPhotos,
                        prevRecentPhotoUrls,
                        newRecentPhotos,
                        newRecentPhotoUrls
                    );
                    console.log('[DEBUG] smoothAddNewPhoto returned:', handled);
                }
                
                // ケース2: 配列の長さが同じで、内容がシフトしている場合（10枚→10枚、最初が削除され最後に追加）
                if (!handled && newRecentPhotos.length === prevRecentPhotos.length && hadAddition) {
                    console.log('[DEBUG] Trying tryIncrementalShift (case 2: same length, shifted)');
                    handled = tryIncrementalShift(
                        middleTrack,
                        prevRecentPhotos,
                        prevRecentPhotoUrls,
                        newRecentPhotos,
                        newRecentPhotoUrls
                    );
                    console.log('[DEBUG] tryIncrementalShift returned:', handled);
                }
                
                // ケース3: 配列の長さが同じで、新しい写真が最後に追加されている場合（位置を保持して追加）
                if (!handled && newRecentPhotos.length === prevRecentPhotos.length && hadAddition) {
                    console.log('[DEBUG] Trying smoothAddNewPhotoAtEnd (case 3: same length, new photo at end)');
                    // 新しい写真が最後に追加されているか確認
                    const newPhotoAtEnd = newRecentPhotos[newRecentPhotos.length - 1];
                    const prevPhotoAtEnd = prevRecentPhotos[prevRecentPhotos.length - 1];
                    const isNewPhotoAtEnd = newPhotoAtEnd !== prevPhotoAtEnd;
                    const prevPhotosMatch = prevRecentPhotos.slice(0, -1).every((photo, i) => photo === newRecentPhotos[i]);
                    
                    if (isNewPhotoAtEnd && prevPhotosMatch) {
                        console.log('[DEBUG] New photo is at the end, using smoothAddNewPhotoAtEnd');
                        handled = smoothAddNewPhotoAtEnd(
                            middleTrack,
                            prevRecentPhotos,
                            prevRecentPhotoUrls,
                            newRecentPhotos,
                            newRecentPhotoUrls
                        );
                        console.log('[DEBUG] smoothAddNewPhotoAtEnd returned:', handled);
                    }
                }
                
                recentPhotos = newRecentPhotos;
                recentPhotoUrls = newRecentPhotoUrls;
                if (!handled) {
                    // 位置を保持しようとする（新しい写真が追加された可能性がある場合）
                    // hasNewPhotoInRecentがtrueの場合、位置を保持（hadAdditionがfalseでも、recentPhotosの内容が変わっている場合は保持）
                    const shouldPreserve = hasNewPhotoInRecent && (newRecentPhotos.length >= prevRecentPhotos.length);
                    console.log('[DEBUG] Falling back to renderRecentTrack', {
                        hadAddition,
                        hasNewPhotoInRecent,
                        firstElementChanged,
                        lastElementChanged,
                        shouldPreserve,
                        prevLength: prevRecentPhotos.length,
                        newLength: newRecentPhotos.length,
                        prevFirst: prevRecentPhotos[0],
                        newFirst: newRecentPhotos[0],
                        prevLast: prevRecentPhotos[prevRecentPhotos.length - 1],
                        newLast: newRecentPhotos[newRecentPhotos.length - 1]
                    });
                    renderRecentTrack(shouldPreserve);
                }
            }

            const payloadTopPhotos = Array.isArray(payload.top_photos) ? payload.top_photos : null;
            const payloadTopPhotoUrls = Array.isArray(payload.top_photo_urls) ? payload.top_photo_urls : null;
            // 11枚目~30枚目が1レーン目
            const newTopPhotos = payloadTopPhotos ? payloadTopPhotos.slice() : currentPhotos.slice(10, 30);
            const newTopPhotoUrls = payloadTopPhotoUrls
                ? payloadTopPhotoUrls.slice()
                : (Array.isArray(newPhotoUrls)
                    ? newPhotoUrls.slice(10, 30)
                    : newTopPhotos.map(buildPhotoUrl));

            const topChanged = !arraysEqual(newTopPhotos, topPhotos) || !arraysEqual(newTopPhotoUrls, topPhotoUrls);

            if (topChanged) {
                let handled = false;
                if (newTopPhotos.length === prevTopPhotos.length + 1 && hadAddition) {
                    handled = smoothAddNewPhoto(
                        topTrack,
                        prevTopPhotos,
                        prevTopPhotoUrls,
                        newTopPhotos,
                        newTopPhotoUrls
                    );
                }
                if (!handled) {
                    handled = tryIncrementalShift(
                        topTrack,
                        prevTopPhotos,
                        prevTopPhotoUrls,
                        newTopPhotos,
                        newTopPhotoUrls
                    );
                }
                topPhotos = newTopPhotos;
                topPhotoUrls = newTopPhotoUrls;
                if (!handled) {
                    if (!topTrack && newTopPhotos.length) {
                        insertTopLaneSkeleton();
                    }
                    renderTopTrack();
                }
            }

            lastPhotoCount = currentPhotos.length;
            return hadAddition;
        }

        function createImageElement(url, filename) {
            const img = document.createElement('img');
            img.src = url || buildPhotoUrl(filename);
            img.alt = 'Photo';
            return img;
        }

        function initializeSlideshow() {
            const tracks = document.querySelectorAll('.slide-track');
            
            tracks.forEach((track) => {
                track.classList.add('init');
                
                const images = track.querySelectorAll('img');
                
                if (images.length === 0) {
                    return;
                }
                
                let loadedCount = 0;
                const totalImages = images.length;
                
                function checkAllLoaded() {
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        startAnimation(track);
                    }
                }
                
                images.forEach(img => {
                    if (img.complete) {
                        checkAllLoaded();
                    } else {
                        img.addEventListener('load', checkAllLoaded);
                        img.addEventListener('error', checkAllLoaded);
                    }
                });
                
                setTimeout(() => {
                    if (track.classList.contains('init')) {
                        startAnimation(track);
                    }
                }, 5000);
            });
        }
        
        function startAnimation(track) {
            if (track.dataset.loopEnabled !== '1') {
                track.classList.remove('animate');
                track.style.animation = 'none';
                const loop = animationLoops.get(track);
                if (loop) {
                    loop.isRunning = false;
                }
                return;
            }
            track.classList.remove('init');
            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth > 0) {
                startJavaScriptAnimation(track, firstSetWidth, 0);
            }
        }

        function restartTrackAnimation(track, preservePosition = false) {
            if (!track) {
                return;
            }
            if (track.dataset.loopEnabled !== '1') {
                track.classList.remove('animate');
                track.style.animation = 'none';
                const loop = animationLoops.get(track);
                if (loop) {
                    loop.isRunning = false;
                }
                return;
            }
            
            const firstSetWidth = track.dataset.firstSetWidth ? parseFloat(track.dataset.firstSetWidth) : 0;
            if (firstSetWidth <= 0) {
                return;
            }
            
            let startX = 0;
            if (preservePosition) {
                const loop = animationLoops.get(track);
                if (loop && loop.isRunning) {
                    // 現在の位置を取得
                    const computedStyle = window.getComputedStyle(track);
                    const currentTransform = computedStyle.transform;
                    if (currentTransform && currentTransform !== 'none') {
                        const matrix = currentTransform.match(/matrix\(([^)]+)\)/);
                        if (matrix) {
                            const values = matrix[1].split(',').map(v => parseFloat(v.trim()));
                            startX = values[4] || 0;
                        }
                    }
                } else {
                    const currentProgress = getCurrentAnimationProgress(track);
                    startX = -(currentProgress * firstSetWidth);
                }
            }
            
            track.classList.remove('animate');
            track.classList.add('init');
            track.style.animation = 'none';
            void track.offsetWidth;
            startJavaScriptAnimation(track, firstSetWidth, startX);
        }
        
        window.addEventListener('load', function() {
            if (!topTrack && topPhotos.length) {
                insertTopLaneSkeleton();
            }
            renderTopTrack();
            renderRecentTrack();
            setTimeout(initializeSlideshow, 100);
            scheduleNextPoll();
        });
        
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                const tracks = document.querySelectorAll('.slide-track');
                tracks.forEach(track => {
                    if (!track.classList.contains('animate') && track.querySelectorAll('img').length > 0) {
                        startAnimation(track);
                    }
                });
                requestImmediateRefresh();
            } else {
                if (pollTimer) {
                    clearTimeout(pollTimer);
                    pollTimer = null;
                }
            }
        });

        function insertTopLaneSkeleton() {
            const container = document.querySelector('.slideshow-app');
            const mainSection = document.querySelector('.slideshow-main');
            const topRowFragment = document.createElement('div');
            topRowFragment.className = 'slider-row top-row';

            const trackDiv = document.createElement('div');
            trackDiv.className = 'slide-track';
            trackDiv.id = 'topTrack';
            trackDiv.dataset.firstSetLength = '0';
            trackDiv.dataset.loopEnabled = '0';
            topRowFragment.appendChild(trackDiv);

            container.insertBefore(topRowFragment, mainSection);

            document.body.classList.remove('single-lane');

            topTrack = trackDiv;
        }
    </script>
</body>
</html>